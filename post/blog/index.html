<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C&#43;&#43;核心编程 | FreanJa&#39;s Blog</title>
<meta name="keywords" content="" />
<meta name="description" content="本阶段主要针对C&#43;&#43;==面向对象==编程技术做详细讲解，探讨C&#43;&#43;中的核心和精髓。
1 内存分区模型 C&#43;&#43;程序在执行时，将内存大方向划分为4个区域
 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收  内存四区意义：
不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程
1.1 程序运行前 在程序编译后，生成了exe可执行程序，*未执行该程序前*分为两个区域 *代码区：* 存放 CPU 执行的机器指令 代码区是*共享*的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 代码区是*只读*的，使其只读的原因是防止程序意外地修改了它的指令 *全局区：* 全局变量和静态变量存放在此. 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ==该区域的数据在程序结束后由操作系统释放==.  示例：
//全局变量 int g_a = 10; int g_b = 10; //全局常量 const int c_g_a = 10; const int c_g_b = 10; int main() { //局部变量 	int a = 10; int b = 10; //打印地址 	cout &lt;&lt; &#34;局部变量a地址为： &#34; &lt;&lt; (int)&amp;a &lt;&lt; endl; cout &lt;&lt; &#34;局部变量b地址为： &#34; &lt;&lt; (int)&amp;b &lt;&lt; endl; cout &lt;&lt; &#34;全局变量g_a地址为： &#34; &lt;&lt; (int)&amp;g_a &lt;&lt; endl; cout &lt;&lt; &#34;全局变量g_b地址为： &#34; &lt;&lt; (int)&amp;g_b &lt;&lt; endl; //静态变量 	static int s_a = 10; static int s_b = 10; cout &lt;&lt; &#34;静态变量s_a地址为： &#34; &lt;&lt; (int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; &#34;静态变量s_b地址为： &#34; &lt;&lt; (int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; &#34;字符串常量地址为： &#34; &lt;&lt; (int)&amp;&#34;hello world&#34; &lt;&lt; endl; cout &lt;&lt; &#34;字符串常量地址为： &#34; &lt;&lt; (int)&amp;&#34;hello world1&#34; &lt;&lt; endl; cout &lt;&lt; &#34;全局常量c_g_a地址为： &#34; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &#34;全局常量c_g_b地址为： &#34; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout &lt;&lt; &#34;局部常量c_l_a地址为： &#34; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl; cout &lt;&lt; &#34;局部常量c_l_b地址为： &#34; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl; system(&#34;pause&#34;); return 0; } 打印结果：">
<meta name="author" content="Me">
<link rel="canonical" href="https://github.com/FreanJa/freanja.github.io/post/blog/" />
<link crossorigin="anonymous" href="/FreanJa/freanja.github.io/assets/css/stylesheet.min.b4f41e8115821784b756edfd28d8497a95b480a414695c43ba128f9296a762df.css" integrity="sha256-tPQegRWCF4S3Vu39KNhJepW0gKQUaVxDuhKPkpanYt8=" rel="preload stylesheet" as="style">
<link rel="preload" href="/apple-touch-icon.png" as="image">
<script defer crossorigin="anonymous" src="/FreanJa/freanja.github.io/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://github.com/FreanJa/freanja.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://github.com/FreanJa/freanja.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://github.com/FreanJa/freanja.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://github.com/FreanJa/freanja.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://github.com/FreanJa/freanja.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.88.1" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="C&#43;&#43;核心编程" />
<meta property="og:description" content="本阶段主要针对C&#43;&#43;==面向对象==编程技术做详细讲解，探讨C&#43;&#43;中的核心和精髓。
1 内存分区模型 C&#43;&#43;程序在执行时，将内存大方向划分为4个区域
 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收  内存四区意义：
不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程
1.1 程序运行前 在程序编译后，生成了exe可执行程序，*未执行该程序前*分为两个区域 *代码区：* 存放 CPU 执行的机器指令 代码区是*共享*的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 代码区是*只读*的，使其只读的原因是防止程序意外地修改了它的指令 *全局区：* 全局变量和静态变量存放在此. 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ==该区域的数据在程序结束后由操作系统释放==.  示例：
//全局变量 int g_a = 10; int g_b = 10; //全局常量 const int c_g_a = 10; const int c_g_b = 10; int main() { //局部变量 	int a = 10; int b = 10; //打印地址 	cout &lt;&lt; &#34;局部变量a地址为： &#34; &lt;&lt; (int)&amp;a &lt;&lt; endl; cout &lt;&lt; &#34;局部变量b地址为： &#34; &lt;&lt; (int)&amp;b &lt;&lt; endl; cout &lt;&lt; &#34;全局变量g_a地址为： &#34; &lt;&lt; (int)&amp;g_a &lt;&lt; endl; cout &lt;&lt; &#34;全局变量g_b地址为： &#34; &lt;&lt; (int)&amp;g_b &lt;&lt; endl; //静态变量 	static int s_a = 10; static int s_b = 10; cout &lt;&lt; &#34;静态变量s_a地址为： &#34; &lt;&lt; (int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; &#34;静态变量s_b地址为： &#34; &lt;&lt; (int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; &#34;字符串常量地址为： &#34; &lt;&lt; (int)&amp;&#34;hello world&#34; &lt;&lt; endl; cout &lt;&lt; &#34;字符串常量地址为： &#34; &lt;&lt; (int)&amp;&#34;hello world1&#34; &lt;&lt; endl; cout &lt;&lt; &#34;全局常量c_g_a地址为： &#34; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &#34;全局常量c_g_b地址为： &#34; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout &lt;&lt; &#34;局部常量c_l_a地址为： &#34; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl; cout &lt;&lt; &#34;局部常量c_l_b地址为： &#34; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl; system(&#34;pause&#34;); return 0; } 打印结果：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://github.com/FreanJa/freanja.github.io/post/blog/" /><meta property="og:image" content="https://github.com/levi.jpeg"/><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-09-20T16:56:33&#43;08:00" />
<meta property="article:modified_time" content="2021-09-20T16:56:33&#43;08:00" /><meta property="og:site_name" content="ExampleSite" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://github.com/levi.jpeg"/>

<meta name="twitter:title" content="C&#43;&#43;核心编程"/>
<meta name="twitter:description" content="本阶段主要针对C&#43;&#43;==面向对象==编程技术做详细讲解，探讨C&#43;&#43;中的核心和精髓。
1 内存分区模型 C&#43;&#43;程序在执行时，将内存大方向划分为4个区域
 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收  内存四区意义：
不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程
1.1 程序运行前 在程序编译后，生成了exe可执行程序，*未执行该程序前*分为两个区域 *代码区：* 存放 CPU 执行的机器指令 代码区是*共享*的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 代码区是*只读*的，使其只读的原因是防止程序意外地修改了它的指令 *全局区：* 全局变量和静态变量存放在此. 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ==该区域的数据在程序结束后由操作系统释放==.  示例：
//全局变量 int g_a = 10; int g_b = 10; //全局常量 const int c_g_a = 10; const int c_g_b = 10; int main() { //局部变量 	int a = 10; int b = 10; //打印地址 	cout &lt;&lt; &#34;局部变量a地址为： &#34; &lt;&lt; (int)&amp;a &lt;&lt; endl; cout &lt;&lt; &#34;局部变量b地址为： &#34; &lt;&lt; (int)&amp;b &lt;&lt; endl; cout &lt;&lt; &#34;全局变量g_a地址为： &#34; &lt;&lt; (int)&amp;g_a &lt;&lt; endl; cout &lt;&lt; &#34;全局变量g_b地址为： &#34; &lt;&lt; (int)&amp;g_b &lt;&lt; endl; //静态变量 	static int s_a = 10; static int s_b = 10; cout &lt;&lt; &#34;静态变量s_a地址为： &#34; &lt;&lt; (int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; &#34;静态变量s_b地址为： &#34; &lt;&lt; (int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; &#34;字符串常量地址为： &#34; &lt;&lt; (int)&amp;&#34;hello world&#34; &lt;&lt; endl; cout &lt;&lt; &#34;字符串常量地址为： &#34; &lt;&lt; (int)&amp;&#34;hello world1&#34; &lt;&lt; endl; cout &lt;&lt; &#34;全局常量c_g_a地址为： &#34; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &#34;全局常量c_g_b地址为： &#34; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout &lt;&lt; &#34;局部常量c_l_a地址为： &#34; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl; cout &lt;&lt; &#34;局部常量c_l_b地址为： &#34; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl; system(&#34;pause&#34;); return 0; } 打印结果："/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://github.com/FreanJa/freanja.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "C++核心编程",
      "item": "https://github.com/FreanJa/freanja.github.io/post/blog/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++核心编程",
  "name": "C\u002b\u002b核心编程",
  "description": "本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。\n1 内存分区模型 C++程序在执行时，将内存大方向划分为4个区域\n 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收  内存四区意义：\n不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n1.1 程序运行前 在程序编译后，生成了exe可执行程序，*未执行该程序前*分为两个区域 *代码区：* 存放 CPU 执行的机器指令 代码区是*共享*的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 代码区是*只读*的，使其只读的原因是防止程序意外地修改了它的指令 *全局区：* 全局变量和静态变量存放在此. 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ==该区域的数据在程序结束后由操作系统释放==.  示例：\n//全局变量 int g_a = 10; int g_b = 10; //全局常量 const int c_g_a = 10; const int c_g_b = 10; int main() { //局部变量 \tint a = 10; int b = 10; //打印地址 \tcout \u0026lt;\u0026lt; \u0026#34;局部变量a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;局部变量b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局变量g_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;g_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局变量g_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;g_b \u0026lt;\u0026lt; endl; //静态变量 \tstatic int s_a = 10; static int s_b = 10; cout \u0026lt;\u0026lt; \u0026#34;静态变量s_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;s_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;静态变量s_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;s_b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;字符串常量地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;\u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;字符串常量地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;\u0026#34;hello world1\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局常量c_g_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_g_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局常量c_g_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_g_b \u0026lt;\u0026lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout \u0026lt;\u0026lt; \u0026#34;局部常量c_l_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_l_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;局部常量c_l_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_l_b \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 打印结果：",
  "keywords": [
    
  ],
  "articleBody": " 本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。\n1 内存分区模型 C++程序在执行时，将内存大方向划分为4个区域\n 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收  内存四区意义：\n不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n1.1 程序运行前 在程序编译后，生成了exe可执行程序，*未执行该程序前*分为两个区域 *代码区：* 存放 CPU 执行的机器指令 代码区是*共享*的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 代码区是*只读*的，使其只读的原因是防止程序意外地修改了它的指令 *全局区：* 全局变量和静态变量存放在此. 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ==该区域的数据在程序结束后由操作系统释放==.  示例：\n//全局变量 int g_a = 10; int g_b = 10; //全局常量 const int c_g_a = 10; const int c_g_b = 10; int main() { //局部变量 \tint a = 10; int b = 10; //打印地址 \tcout  \"局部变量a地址为： \"  (int)\u0026a  endl; cout  \"局部变量b地址为： \"  (int)\u0026b  endl; cout  \"全局变量g_a地址为： \"  (int)\u0026g_a  endl; cout  \"全局变量g_b地址为： \"  (int)\u0026g_b  endl; //静态变量 \tstatic int s_a = 10; static int s_b = 10; cout  \"静态变量s_a地址为： \"  (int)\u0026s_a  endl; cout  \"静态变量s_b地址为： \"  (int)\u0026s_b  endl; cout  \"字符串常量地址为： \"  (int)\u0026\"hello world\"  endl; cout  \"字符串常量地址为： \"  (int)\u0026\"hello world1\"  endl; cout  \"全局常量c_g_a地址为： \"  (int)\u0026c_g_a  endl; cout  \"全局常量c_g_b地址为： \"  (int)\u0026c_g_b  endl; const int c_l_a = 10; const int c_l_b = 10; cout  \"局部常量c_l_a地址为： \"  (int)\u0026c_l_a  endl; cout  \"局部常量c_l_b地址为： \"  (int)\u0026c_l_b  endl; system(\"pause\"); return 0; } 打印结果：\n1545017602518\n总结：\n C++中在程序运行前分为全局区和代码区 代码区特点是共享和只读 全局区中存放全局变量、静态变量、常量 常量区中存放 const修饰的全局常量 和 字符串常量  1.2 程序运行后 *栈区：* 由编译器自动分配释放, 存放函数的参数值,局部变量等 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放  示例：\nint * func() { int a = 10; return \u0026a; } int main() { int *p = func(); cout  *p  endl; cout  *p  endl; system(\"pause\"); return 0; } *堆区：* 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收 在C++中主要利用new在堆区开辟内存  示例：\nint* func() { int* a = new int(10); return a; } int main() { int *p = func(); cout  *p  endl; cout  *p  endl; system(\"pause\"); return 0; } 总结：\n堆区数据由程序员管理开辟和释放\n堆区数据利用new关键字进行开辟内存\n1.3 new操作符 C++中利用==new==操作符在堆区开辟数据 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete== 语法：` new 数据类型` 利用new创建的数据，会返回该数据对应的类型的指针  示例1： 基本语法\nint* func() { int* a = new int(10); return a; } int main() { int *p = func(); cout  *p  endl; cout  *p  endl; //利用delete释放堆区数据 \tdelete p; //cout  system(\"pause\"); return 0; } 示例2：开辟数组\n//堆区开辟数组 int main() { int* arr = new int[10]; for (int i = 0; i  10; i++) { arr[i] = i + 100; } for (int i = 0; i  10; i++) { cout  arr[i]  endl; } //释放数组 delete 后加 [] \tdelete[] arr; system(\"pause\"); return 0; } ​```## 2 引用 ### 2.1 引用的基本使用 **作用： **给变量起别名 *语法：* `数据类型 \u0026别名 = 原名` *示例：* ​```C++ int main() { int a = 10; int \u0026b = a; cout  \"a = \"  a  endl; cout  \"b = \"  b  endl; b = 100; cout  \"a = \"  a  endl; cout  \"b = \"  b  endl; system(\"pause\"); return 0; } ​```### 2.2 引用注意事项 * 引用必须初始化 * 引用在初始化后，不可以改变 示例： ​```C++ int main() { int a = 10; int b = 20; //int \u0026c; //错误，引用必须初始化 \tint \u0026c = a; //一旦初始化后，就不可以更改 \tc = b; //这是赋值操作，不是更改引用  cout  \"a = \"  a  endl; cout  \"b = \"  b  endl; cout  \"c = \"  c  endl; system(\"pause\"); return 0; } ​```### 2.3 引用做函数参数 **作用：**函数传参时，可以利用引用的技术让形参修饰实参 **优点：**可以简化指针修改实参 *示例：* ​```C++ //1. 值传递 void mySwap01(int a, int b) { int temp = a; a = b; b = temp; } //2. 地址传递 void mySwap02(int* a, int* b) { int temp = *a; *a = *b; *b = temp; } //3. 引用传递 void mySwap03(int\u0026 a, int\u0026 b) { int temp = a; a = b; b = temp; } int main() { int a = 10; int b = 20; mySwap01(a, b); cout  \"a:\"  a  \" b:\"  b  endl; mySwap02(\u0026a, \u0026b); cout  \"a:\"  a  \" b:\"  b  endl; mySwap03(a, b); cout  \"a:\"  a  \" b:\"  b  endl; system(\"pause\"); return 0; } ​``` 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单### 2.4 引用做函数返回值 作用：引用是可以作为函数的返回值存在的 注意：*不要返回局部变量引用* 用法：函数调用作为左值 *示例：* ​```C++ //返回局部变量引用 int\u0026 test01() { int a = 10; //局部变量 \treturn a; } //返回静态变量引用 int\u0026 test02() { static int a = 20; return a; } int main() { //不能返回局部变量的引用 \tint\u0026 ref = test01(); cout  \"ref = \"  ref  endl; cout  \"ref = \"  ref  endl; //如果函数做左值，那么必须返回引用 \tint\u0026 ref2 = test02(); cout  \"ref2 = \"  ref2  endl; cout  \"ref2 = \"  ref2  endl; test02() = 1000; cout  \"ref2 = \"  ref2  endl; cout  \"ref2 = \"  ref2  endl; system(\"pause\"); return 0; } 2.5 引用的本质 本质：引用的本质在c++内部实现是一个指针常量.\n讲解示例：\n//发现是引用，转换为 int* const ref = \u0026a; void func(int\u0026 ref){ ref = 100; // ref是引用，转换为*ref = 100 } int main(){ int a = 10; //自动转换为 int* const ref = \u0026a; 指针常量是指针指向不可改，也说明为什么引用不可更改 \tint\u0026 ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;  cout  \"a:\"  a  endl; cout  \"ref:\"  ref  endl; func(a); return 0; } 结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n2.6 常量引用 **作用：**常量引用主要用来修饰形参，防止误操作\n在函数形参列表中，可以加==const修饰形参==，防止形参改变实参\n示例：\n//引用使用的场景，通常用来修饰形参 void showValue(const int\u0026 v) { //v += 10; \tcout  v  endl; } int main() { //int\u0026 ref = 10; 引用本身需要一个合法的内存空间，因此这行错误 \t//加入const就可以了，编译器优化代码，int temp = 10; const int\u0026 ref = temp; \tconst int\u0026 ref = 10; //ref = 100; //加入const后不可以修改变量 \tcout  ref  endl; //函数中利用常量引用防止误操作修改实参 \tint a = 10; showValue(a); system(\"pause\"); return 0; } ​```## 3 函数提高 ### 3.1 函数默认参数 在C++中，函数的形参列表中的形参是可以有默认值的。 语法：` 返回值类型 函数名 （参数= 默认值）{}` *示例：* ​```C++ int func(int a, int b = 10, int c = 10) { return a + b + c; } //1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值 //2. 如果函数声明有默认值，函数实现的时候就不能有默认参数 int func2(int a = 10, int b = 10); int func2(int a, int b) { return a + b; } int main() { cout  \"ret = \"  func(20, 20)  endl; cout  \"ret = \"  func(100)  endl; system(\"pause\"); return 0; } ​```### 3.2 函数占位参数 C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置 *语法：* `返回值类型 函数名 (数据类型){}` 在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术 *示例：* ​```C++ //函数占位参数 ，占位参数也可以有默认参数 void func(int a, int) { cout  \"this is func\"  endl; } int main() { func(10,10); //占位参数必须填补  system(\"pause\"); return 0; } ​```### 3.3 函数重载 #### 3.3.1 函数重载概述 **作用：**函数名可以相同，提高复用性 *函数重载满足条件：* * 同一个作用域下 * 函数名称相同 * 函数参数*类型不同* 或者 *个数不同* 或者 *顺序不同* *注意:* 函数的返回值不可以作为函数重载的条件 *示例：* ​```C++ //函数重载需要函数都在同一个作用域下 void func() { cout  \"func 的调用！\"  endl; } void func(int a) { cout  \"func (int a) 的调用！\"  endl; } void func(double a) { cout  \"func (double a)的调用！\"  endl; } void func(int a ,double b) { cout  \"func (int a ,double b) 的调用！\"  endl; } void func(double a ,int b) { cout  \"func (double a ,int b)的调用！\"  endl; } //函数返回值不可以作为函数重载条件 //int func(double a, int b) //{ //\tcout //}  int main() { func(); func(10); func(3.14); func(10,3.14); func(3.14 , 10); system(\"pause\"); return 0; } ​```#### 3.3.2 函数重载注意事项 * 引用作为重载条件 * 函数重载碰到函数默认参数 *示例：* ​```C++ //函数重载注意事项 //1、引用作为重载条件  void func(int \u0026a) { cout  \"func (int \u0026a) 调用 \"  endl; } void func(const int \u0026a) { cout  \"func (const int \u0026a) 调用 \"  endl; } //2、函数重载碰到函数默认参数  void func2(int a, int b = 10) { cout  \"func2(int a, int b = 10) 调用\"  endl; } void func2(int a) { cout  \"func2(int a) 调用\"  endl; } int main() { int a = 10; func(a); //调用无const \tfunc(10);//调用有const  //func2(10); //碰到默认参数产生歧义，需要避免  system(\"pause\"); return 0; } ​```## *4* 类和对象 C++面向对象的三大特性为：==封装、继承、多态== C++认为==万事万物都皆为对象==，对象上有其属性和行为 *例如：* 人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌... 车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调... 具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类 ### 4.1 封装 #### 4.1.1 封装的意义 封装是C++面向对象三大特性之一 封装的意义： * 将属性和行为作为一个整体，表现生活中的事物 * 将属性和行为加以权限控制 *封装意义一：* 在设计类的时候，属性和行为写在一起，表现事物 *语法：* `class 类名{ 访问权限： 属性 / 行为 };` **示例1：**设计一个圆类，求圆的周长 *示例代码：* ​```C++ //圆周率 const double PI = 3.14; //1、封装的意义 //将属性和行为作为一个整体，用来表现生活中的事物  //封装一个圆类，求圆的周长 //class代表设计一个类，后面跟着的是类名 class Circle { public: //访问权限 公共的权限  //属性 \tint m_r;//半径  //行为 \t//获取到圆的周长 \tdouble calculateZC() { //2 * pi * r \t//获取圆的周长 \treturn 2 * PI * m_r; } }; int main() { //通过圆类，创建圆的对象 \t// c1就是一个具体的圆 \tCircle c1; c1.m_r = 10; //给圆对象的半径 进行赋值操作  //2 * pi * 10 = = 62.8 \tcout  \"圆的周长为： \"  c1.calculateZC()  endl; system(\"pause\"); return 0; } **示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号\n示例2代码：\n//学生类 class Student { public: void setName(string name) { m_name = name; } void setID(int id) { m_id = id; } void showStudent() { cout  \"name:\"  m_name  \" ID:\"  m_id  endl; } public: string m_name; int m_id; }; int main() { Student stu; stu.setName(\"德玛西亚\"); stu.setID(250); stu.showStudent(); system(\"pause\"); return 0; } 封装意义二：\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\n访问权限有三种：\n public 公共权限 protected 保护权限 private 私有权限  示例：\n//三种权限 //公共权限 public 类内可以访问 类外可以访问 //保护权限 protected 类内可以访问 类外不可以访问 //私有权限 private 类内可以访问 类外不可以访问  class Person { //姓名 公共权限 public: string m_Name; //汽车 保护权限 protected: string m_Car; //银行卡密码 私有权限 private: int m_Password; public: void func() { m_Name = \"张三\"; m_Car = \"拖拉机\"; m_Password = 123456; } }; int main() { Person p; p.m_Name = \"李四\"; //p.m_Car = \"奔驰\"; //保护权限类外访问不到 \t//p.m_Password = 123; //私有权限类外访问不到  system(\"pause\"); return 0; } ​```#### 4.1.2 struct和class区别 在C++中 struct和class唯一的*区别*就在于 *默认的访问权限不同* 区别： * struct 默认权限为公共 * class 默认权限为私有 ​```C++ class C1 { int m_A; //默认是私有权限 }; struct C2 { int m_A; //默认是公共权限 }; int main() { C1 c1; c1.m_A = 10; //错误，访问权限是私有  C2 c2; c2.m_A = 10; //正确，访问权限是公共  system(\"pause\"); return 0; } ​```#### 4.1.3 成员属性设置为私有 **优点1：**将所有成员属性设置为私有，可以自己控制读写权限 **优点2：**对于写权限，我们可以检测数据的有效性 *示例：* ​```C++ class Person { public: //姓名设置可读可写 \tvoid setName(string name) { m_Name = name; } string getName() { return m_Name; } //获取年龄 \tint getAge() { return m_Age; } //设置年龄 \tvoid setAge(int age) { if (age  0 || age  150) { cout  \"你个老妖精!\"  endl; return; } m_Age = age; } //情人设置为只写 \tvoid setLover(string lover) { m_Lover = lover; } private: string m_Name; //可读可写 姓名 \tint m_Age; //只读 年龄  string m_Lover; //只写 情人 }; int main() { Person p; //姓名设置 \tp.setName(\"张三\"); cout  \"姓名： \"  p.getName()  endl; //年龄设置 \tp.setAge(50); cout  \"年龄： \"  p.getAge()  endl; //情人设置 \tp.setLover(\"苍井\"); //cout  system(\"pause\"); return 0; } 练习案例1：设计立方体类\n设计立方体类(Cube)\n求出立方体的面积和体积\n分别用全局函数和成员函数判断两个立方体是否相等。\n1545533548532\n练习案例2：点和圆的关系\n设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。\n1545533829184\n4.2 对象的初始化和清理  生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全 C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。  4.2.1 构造函数和析构函数 对象的初始化和清理也是两个非常重要的安全问题\n一个对象或者变量没有初始状态，对其使用后果是未知 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题  c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供\n编译器提供的构造函数和析构函数是空实现。\n 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。  构造函数语法：类名(){}\n 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次  析构函数语法： ~类名(){}\n 析构函数，没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次  class Person { public: //构造函数 \tPerson() { cout  \"Person的构造函数调用\"  endl; } //析构函数 \t~Person() { cout  \"Person的析构函数调用\"  endl; } }; void test01() { Person p; } int main() { test01(); system(\"pause\"); return 0; } ​```#### 4.2.2 构造函数的分类及调用 两种分类方式： 按参数分为： 有参构造和无参构造 按类型分为： 普通构造和拷贝构造 三种调用方式： 括号法 显示法 隐式转换法 *示例：* ​```C++ //1、构造函数分类 // 按照参数分类分为 有参和无参构造 无参又称为默认构造函数 // 按照类型分类分为 普通构造和拷贝构造  class Person { public: //无参（默认）构造函数 \tPerson() { cout  \"无参构造函数!\"  endl; } //有参构造函数 \tPerson(int a) { age = a; cout  \"有参构造函数!\"  endl; } //拷贝构造函数 \tPerson(const Person\u0026 p) { age = p.age; cout  \"拷贝构造函数!\"  endl; } //析构函数 \t~Person() { cout  \"析构函数!\"  endl; } public: int age; }; //2、构造函数的调用 //调用无参构造函数 void test01() { Person p; //调用无参构造函数 } //调用有参的构造函数 void test02() { //2.1 括号法，常用 \tPerson p1(10); //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 \t//Person p2();  //2.2 显式法 \tPerson p2 = Person(10); Person p3 = Person(p2); //Person(10)单独写就是匿名对象 当前行结束之后，马上析构  //2.3 隐式转换法 \tPerson p4 = 10; // Person p4 = Person(10); \tPerson p5 = p4; // Person p5 = Person(p4);  //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 \t//Person p5(p4); } int main() { test01(); //test02();  system(\"pause\"); return 0; } ​```#### 4.2.3 拷贝构造函数调用时机 C++中拷贝构造函数调用时机通常有三种情况 * 使用一个已经创建完毕的对象来初始化一个新对象 * 值传递的方式给函数参数传值 * 以值方式返回局部对象 *示例：* ​```C++ class Person { public: Person() { cout  \"无参构造函数!\"  endl; mAge = 0; } Person(int age) { cout  \"有参构造函数!\"  endl; mAge = age; } Person(const Person\u0026 p) { cout  \"拷贝构造函数!\"  endl; mAge = p.mAge; } //析构函数在释放内存之前调用 \t~Person() { cout  \"析构函数!\"  endl; } public: int mAge; }; //1. 使用一个已经创建完毕的对象来初始化一个新对象 void test01() { Person man(100); //p对象已经创建完毕 \tPerson newman(man); //调用拷贝构造函数 \tPerson newman2 = man; //拷贝构造  //Person newman3; \t//newman3 = man; //不是调用拷贝构造函数，赋值操作 } //2. 值传递的方式给函数参数传值 //相当于Person p1 = p; void doWork(Person p1) {} void test02() { Person p; //无参构造函数 \tdoWork(p); } //3. 以值方式返回局部对象 Person doWork2() { Person p1; cout  (int *)\u0026p1  endl; return p1; } void test03() { Person p = doWork2(); cout  (int *)\u0026p  endl; } int main() { //test01(); \t//test02(); \ttest03(); system(\"pause\"); return 0; } ​```#### 4.2.4 构造函数调用规则 默认情况下，c++编译器至少给一个类添加3个函数 1．默认构造函数(无参，函数体为空) 2．默认析构函数(无参，函数体为空) 3．默认拷贝构造函数，对属性进行值拷贝 构造函数调用规则如下： * 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造 * 如果用户定义拷贝构造函数，c++不会再提供其他构造函数 示例： ​```C++ class Person { public: //无参（默认）构造函数 \tPerson() { cout  \"无参构造函数!\"  endl; } //有参构造函数 \tPerson(int a) { age = a; cout  \"有参构造函数!\"  endl; } //拷贝构造函数 \tPerson(const Person\u0026 p) { age = p.age; cout  \"拷贝构造函数!\"  endl; } //析构函数 \t~Person() { cout  \"析构函数!\"  endl; } public: int age; }; void test01() { Person p1(18); //如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作 \tPerson p2(p1); cout  \"p2的年龄为： \"  p2.age  endl; } void test02() { //如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造 \tPerson p1; //此时如果用户自己没有提供默认构造，会出错 \tPerson p2(10); //用户提供的有参 \tPerson p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供  //如果用户提供拷贝构造，编译器不会提供其他构造函数 \tPerson p4; //此时如果用户自己没有提供默认构造，会出错 \tPerson p5(10); //此时如果用户自己没有提供有参，会出错 \tPerson p6(p5); //用户自己提供拷贝构造 } int main() { test01(); system(\"pause\"); return 0; } ​```#### 4.2.5 深拷贝与浅拷贝 深浅拷贝是面试经典问题，也是常见的一个坑 浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间，进行拷贝操作 *示例：* ​```C++ class Person { public: //无参（默认）构造函数 \tPerson() { cout  \"无参构造函数!\"  endl; } //有参构造函数 \tPerson(int age ,int height) { cout  \"有参构造函数!\"  endl; m_age = age; m_height = new int(height); } //拷贝构造函数 \tPerson(const Person\u0026 p) { cout  \"拷贝构造函数!\"  endl; //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 \tm_age = p.m_age; m_height = new int(*p.m_height); } //析构函数 \t~Person() { cout  \"析构函数!\"  endl; if (m_height != NULL) { delete m_height; } } public: int m_age; int* m_height; }; void test01() { Person p1(18, 180); Person p2(p1); cout  \"p1的年龄： \"  p1.m_age  \" 身高： \"  *p1.m_height  endl; cout  \"p2的年龄： \"  p2.m_age  \" 身高： \"  *p2.m_height  endl; } int main() { test01(); system(\"pause\"); return 0; } ​``` 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题#### 4.2.6 初始化列表 *作用：* C++提供了初始化列表语法，用来初始化属性 *语法：*`构造函数()：属性1(值1),属性2（值2）... {}` *示例：* ​```C++ class Person { public: ////传统方式初始化 \t//Person(int a, int b, int c) { \t//\tm_A = a; \t//\tm_B = b; \t//\tm_C = c; \t//}  //初始化列表方式初始化 \tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {} void PrintPerson() { cout  \"mA:\"  m_A  endl; cout  \"mB:\"  m_B  endl; cout  \"mC:\"  m_C  endl; } private: int m_A; int m_B; int m_C; }; int main() { Person p(1, 2, 3); p.PrintPerson(); system(\"pause\"); return 0; } ​```#### 4.2.7 类对象作为类成员 C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员 例如： ​```C++ class A {} class B { A a； } B类中有对象A作为成员，A为对象成员\n那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？\n示例：\nclass Phone { public: Phone(string name) { m_PhoneName = name; cout  \"Phone构造\"  endl; } ~Phone() { cout  \"Phone析构\"  endl; } string m_PhoneName; }; class Person { public: //初始化列表可以告诉编译器调用哪一个构造函数 \tPerson(string name, string pName) :m_Name(name), m_Phone(pName) { cout  \"Person构造\"  endl; } ~Person() { cout  \"Person析构\"  endl; } void playGame() { cout  m_Name  \" 使用\"  m_Phone.m_PhoneName  \" 牌手机! \"  endl; } string m_Name; Phone m_Phone; }; void test01() { //当类中成员是其他类对象时，我们称该成员为 对象成员 \t//构造的顺序是 ：先调用对象成员的构造，再调用本类构造 \t//析构顺序与构造相反 \tPerson p(\"张三\" , \"苹果X\"); p.playGame(); } int main() { test01(); system(\"pause\"); return 0; } ​```#### 4.2.8 静态成员 静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为： * 静态成员变量 * 所有对象共享同一份数据 * 在编译阶段分配内存 * 类内声明，类外初始化 * 静态成员函数 * 所有对象共享同一个函数 * 静态成员函数只能访问静态成员变量 **示例1 ：**静态成员变量 ​```C++ class Person { public: static int m_A; //静态成员变量  //静态成员变量特点： \t//1 在编译阶段分配内存 \t//2 类内声明，类外初始化 \t//3 所有对象共享同一份数据  private: static int m_B; //静态成员变量也是有访问权限的 }; int Person::m_A = 10; int Person::m_B = 10; void test01() { //静态成员变量两种访问方式  //1、通过对象 \tPerson p1; p1.m_A = 100; cout  \"p1.m_A = \"  p1.m_A  endl; Person p2; p2.m_A = 200; cout  \"p1.m_A = \"  p1.m_A  endl; //共享同一份数据 \tcout  \"p2.m_A = \"  p2.m_A  endl; //2、通过类名 \tcout  \"m_A = \"  Person::m_A  endl; //cout } int main() { test01(); system(\"pause\"); return 0; } **示例2：**静态成员函数\nclass Person { public: //静态成员函数特点： \t//1 程序共享一个函数 \t//2 静态成员函数只能访问静态成员变量 \tstatic void func() { cout  \"func调用\"  endl; m_A = 100; //m_B = 100; //错误，不可以访问非静态成员变量 \t} static int m_A; //静态成员变量 \tint m_B; // private: //静态成员函数也是有访问权限的 \tstatic void func2() { cout  \"func2调用\"  endl; } }; int Person::m_A = 10; void test01() { //静态成员变量两种访问方式  //1、通过对象 \tPerson p1; p1.func(); //2、通过类名 \tPerson::func(); //Person::func2(); //私有权限访问不到 } int main() { test01(); system(\"pause\"); return 0; } ​```### 4.3 C++对象模型和this指针 #### 4.3.1 成员变量和成员函数分开存储 在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 ​```C++ class Person { public: Person() { mA = 0; } //非静态成员变量占对象空间 \tint mA; //静态成员变量不占对象空间 \tstatic int mB; //函数也不占对象空间，所有函数共享一个函数实例 \tvoid func() { cout  \"mA:\"  this-mA  endl; } //静态成员函数也不占对象空间 \tstatic void sfunc() { } }; int main() { cout  sizeof(Person)  endl; system(\"pause\"); return 0; } ​```#### 4.3.2 this指针概念 通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是：这一块代码是如何区分那个对象调用自己的呢？ c++通过提供特殊的对象指针，this指针，解决上述问题。*this指针指向被调用的成员函数所属的对象* this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义，直接使用即可 this指针的用途： * 当形参和成员变量同名时，可用this指针来区分 * 在类的非静态成员函数中返回对象本身，可使用return *this ​```C++ class Person { public: Person(int age) { //1、当形参和成员变量同名时，可用this指针来区分 \tthis-age = age; } Person\u0026 PersonAddPerson(Person p) { this-age += p.age; //返回对象本身 \treturn *this; } int age; }; void test01() { Person p1(10); cout  \"p1.age = \"  p1.age  endl; Person p2(10); p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1); cout  \"p2.age = \"  p2.age  endl; } int main() { test01(); system(\"pause\"); return 0; } ​```#### 4.3.3 空指针访问成员函数 C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 *示例：* ​```C++ //空指针访问成员函数 class Person { public: void ShowClassName() { cout  \"我是Person类!\"  endl; } void ShowPerson() { if (this == NULL) { return; } cout  mAge  endl; } public: int mAge; }; void test01() { Person * p = NULL; p-ShowClassName(); //空指针，可以调用成员函数 \tp-ShowPerson(); //但是如果成员函数中用到了this指针，就不可以了 } int main() { test01(); system(\"pause\"); return 0; } ​```#### 4.3.4 const修饰成员函数 *常函数：* * 成员函数后加const后我们称为这个函数为*常函数* * 常函数内不可以修改成员属性 * 成员属性声明时加关键字mutable后，在常函数中依然可以修改 *常对象：* * 声明对象前加const称该对象为常对象 * 常对象只能调用常函数 *示例：* ​```C++ class Person { public: Person() { m_A = 0; m_B = 0; } //this指针的本质是一个指针常量，指针的指向不可修改 \t//如果想让指针指向的值也不可以修改，需要声明常函数 \tvoid ShowPerson() const { //const Type* const pointer; \t//this = NULL; //不能修改指针的指向 Person* const this; \t//this-mA = 100; //但是this指针指向的对象的数据是可以修改的  //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 \tthis-m_B = 100; } void MyFunc() const { //mA = 10000; \t} public: int m_A; mutable int m_B; //可修改 可变的 }; //const修饰对象 常对象 void test01() { const Person person; //常量对象 \tcout  person.m_A  endl; //person.mA = 100; //常对象不能修改成员变量的值,但是可以访问 \tperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量  //常对象访问成员函数 \tperson.MyFunc(); //常对象不能调用const的函数  } int main() { test01(); system(\"pause\"); return 0; } ​```### 4.4 友元 生活中你的家有客厅(Public)，有你的卧室(Private) 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜好基友进去。 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元的目的就是让一个函数或者类 访问另一个类中私有成员 友元的关键字为 ==friend== 友元的三种实现 * 全局函数做友元 * 类做友元 * 成员函数做友元 #### 4.4.1 全局函数做友元 ​```C++ class Building { //告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容 \tfriend void goodGay(Building * building); public: Building() { this-m_SittingRoom = \"客厅\"; this-m_BedRoom = \"卧室\"; } public: string m_SittingRoom; //客厅  private: string m_BedRoom; //卧室 }; void goodGay(Building * building) { cout  \"好基友正在访问： \"  building-m_SittingRoom  endl; cout  \"好基友正在访问： \"  building-m_BedRoom  endl; } void test01() { Building b; goodGay(\u0026b); } int main(){ test01(); system(\"pause\"); return 0; } ​```#### 4.4.2 类做友元 ​```C++ class Building; class goodGay { public: goodGay(); void visit(); private: Building *building; }; class Building { //告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容 \tfriend class goodGay; public: Building(); public: string m_SittingRoom; //客厅 private: string m_BedRoom;//卧室 }; Building::Building() { this-m_SittingRoom = \"客厅\"; this-m_BedRoom = \"卧室\"; } goodGay::goodGay() { building = new Building; } void goodGay::visit() { cout  \"好基友正在访问\"  building-m_SittingRoom  endl; cout  \"好基友正在访问\"  building-m_BedRoom  endl; } void test01() { goodGay gg; gg.visit(); } int main(){ test01(); system(\"pause\"); return 0; } ​```#### 4.4.3 成员函数做友元 ​```C++ class Building; class goodGay { public: goodGay(); void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容 \tvoid visit2(); private: Building *building; }; class Building { //告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 \tfriend void goodGay::visit(); public: Building(); public: string m_SittingRoom; //客厅 private: string m_BedRoom;//卧室 }; Building::Building() { this-m_SittingRoom = \"客厅\"; this-m_BedRoom = \"卧室\"; } goodGay::goodGay() { building = new Building; } void goodGay::visit() { cout  \"好基友正在访问\"  building-m_SittingRoom  endl; cout  \"好基友正在访问\"  building-m_BedRoom  endl; } void goodGay::visit2() { cout  \"好基友正在访问\"  building-m_SittingRoom  endl; //cout m_BedRoom } void test01() { goodGay gg; gg.visit(); } int main(){ test01(); system(\"pause\"); return 0; } ​```### 4.5 运算符重载 运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 #### 4.5.1 加号运算符重载 作用：实现两个自定义数据类型相加的运算 ​```C++ class Person { public: Person() {}; Person(int a, int b) { this-m_A = a; this-m_B = b; } //成员函数实现 + 号运算符重载 \tPerson operator+(const Person\u0026 p) { Person temp; temp.m_A = this-m_A + p.m_A; temp.m_B = this-m_B + p.m_B; return temp; } public: int m_A; int m_B; }; //全局函数实现 + 号运算符重载 //Person operator+(const Person\u0026 p1, const Person\u0026 p2) { //\tPerson temp(0, 0); //\ttemp.m_A = p1.m_A + p2.m_A; //\ttemp.m_B = p1.m_B + p2.m_B; //\treturn temp; //}  //运算符重载 可以发生函数重载 Person operator+(const Person\u0026 p2, int val) { Person temp; temp.m_A = p2.m_A + val; temp.m_B = p2.m_B + val; return temp; } void test() { Person p1(10, 10); Person p2(20, 20); //成员函数方式 \tPerson p3 = p2 + p1; //相当于 p2.operaor+(p1) \tcout  \"mA:\"  p3.m_A  \" mB:\"  p3.m_B  endl; Person p4 = p3 + 10; //相当于 operator+(p3,10) \tcout  \"mA:\"  p4.m_A  \" mB:\"  p4.m_B  endl; } int main() { test(); system(\"pause\"); return 0; } ​``` 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的 总结2：不要滥用运算符重载#### 4.5.2 左移运算符重载 作用：可以输出自定义数据类型 ​```C++ class Person { friend ostream\u0026 operator(ostream\u0026 out, Person\u0026 p); public: Person(int a, int b) { this-m_A = a; this-m_B = b; } //成员函数 实现不了 p \t//void operator\t//}  private: int m_A; int m_B; }; //全局函数实现左移重载 //ostream对象只能有一个 ostream\u0026 operator(ostream\u0026 out, Person\u0026 p) { out  \"a:\"  p.m_A  \" b:\"  p.m_B; return out; } void test() { Person p1(10, 20); cout  p1  \"hello world\"  endl; //链式编程 } int main() { test(); system(\"pause\"); return 0; } ​``` 总结：重载左移运算符配合友元可以实现输出自定义数据类型#### 4.5.3 递增运算符重载 作用： 通过重载递增运算符，实现自己的整型数据 ​```C++ class MyInteger { friend ostream\u0026 operator(ostream\u0026 out, MyInteger myint); public: MyInteger() { m_Num = 0; } //前置++ \tMyInteger\u0026 operator++() { //先++ \tm_Num++; //再返回 \treturn *this; } //后置++ \tMyInteger operator++(int) { //先返回 \tMyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； \tm_Num++; return temp; } private: int m_Num; }; ostream\u0026 operator(ostream\u0026 out, MyInteger myint) { out  myint.m_Num; return out; } //前置++ 先++ 再返回 void test01() { MyInteger myInt; cout  ++myInt  endl; cout  myInt  endl; } //后置++ 先返回 再++ void test02() { MyInteger myInt; cout  myInt++  endl; cout  myInt  endl; } int main() { test01(); //test02();  system(\"pause\"); return 0; } ​``` 总结： 前置递增返回引用，后置递增返回值#### 4.5.4 赋值运算符重载 c++编译器至少给一个类添加4个函数 1. 默认构造函数(无参，函数体为空) 2. 默认析构函数(无参，函数体为空) 3. 默认拷贝构造函数，对属性进行值拷贝 4. 赋值运算符 operator=, 对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题 *示例：* ​```C++ class Person { public: Person(int age) { //将年龄数据开辟到堆区 \tm_Age = new int(age); } //重载赋值运算符 \tPerson\u0026 operator=(Person \u0026p) { if (m_Age != NULL) { delete m_Age; m_Age = NULL; } //编译器提供的代码是浅拷贝 \t//m_Age = p.m_Age;  //提供深拷贝 解决浅拷贝的问题 \tm_Age = new int(*p.m_Age); //返回自身 \treturn *this; } ~Person() { if (m_Age != NULL) { delete m_Age; m_Age = NULL; } } //年龄的指针 \tint *m_Age; }; void test01() { Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; //赋值操作  cout  \"p1的年龄为：\"  *p1.m_Age  endl; cout  \"p2的年龄为：\"  *p2.m_Age  endl; cout  \"p3的年龄为：\"  *p3.m_Age  endl; } int main() { test01(); //int a = 10; \t//int b = 20; \t//int c = 30;  //c = b = a; \t//cout \t//cout \t//cout  system(\"pause\"); return 0; } ​```#### 4.5.5 关系运算符重载 **作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作 *示例：* ​```C++ class Person { public: Person(string name, int age) { this-m_Name = name; this-m_Age = age; }; bool operator==(Person \u0026 p) { if (this-m_Name == p.m_Name \u0026\u0026 this-m_Age == p.m_Age) { return true; } else { return false; } } bool operator!=(Person \u0026 p) { if (this-m_Name == p.m_Name \u0026\u0026 this-m_Age == p.m_Age) { return false; } else { return true; } } string m_Name; int m_Age; }; void test01() { //int a = 0; \t//int b = 0;  Person a(\"孙悟空\", 18); Person b(\"孙悟空\", 18); if (a == b) { cout  \"a和b相等\"  endl; } else { cout  \"a和b不相等\"  endl; } if (a != b) { cout  \"a和b不相等\"  endl; } else { cout  \"a和b相等\"  endl; } } int main() { test01(); system(\"pause\"); return 0; } ​```#### 4.5.6 函数调用运算符重载 * 函数调用运算符 () 也可以重载 * 由于重载后使用的方式非常像函数的调用，因此称为仿函数 * 仿函数没有固定写法，非常灵活 *示例：* ​```C++ class MyPrint { public: void operator()(string text) { cout  text  endl; } }; void test01() { //重载的（）操作符 也称为仿函数 \tMyPrint myFunc; myFunc(\"hello world\"); } class MyAdd { public: int operator()(int v1, int v2) { return v1 + v2; } }; void test02() { MyAdd add; int ret = add(10, 10); cout  \"ret = \"  ret  endl; //匿名对象调用 \tcout  \"MyAdd()(100,100) = \"  MyAdd()(100, 100)  endl; } int main() { test01(); test02(); system(\"pause\"); return 0; } ​```### 4.6 继承 *继承是面向对象三大特性之一* 有些类与类之间存在特殊的关系，例如下图中： 1544861202252 我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。 这个时候我们就可以考虑利用继承的技术，减少重复代码 #### 4.6.1 继承的基本语法 例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同 接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处 *普通实现：* ​```C++ //Java页面 class Java { public: void header() { cout  \"首页、公开课、登录、注册...（公共头部）\"  endl; } void footer() { cout  \"帮助中心、交流合作、站内地图...(公共底部)\"  endl; } void left() { cout  \"Java,Python,C++...(公共分类列表)\"  endl; } void content() { cout  \"JAVA学科视频\"  endl; } }; //Python页面 class Python { public: void header() { cout  \"首页、公开课、登录、注册...（公共头部）\"  endl; } void footer() { cout  \"帮助中心、交流合作、站内地图...(公共底部)\"  endl; } void left() { cout  \"Java,Python,C++...(公共分类列表)\"  endl; } void content() { cout  \"Python学科视频\"  endl; } }; //C++页面 class CPP { public: void header() { cout  \"首页、公开课、登录、注册...（公共头部）\"  endl; } void footer() { cout  \"帮助中心、交流合作、站内地图...(公共底部)\"  endl; } void left() { cout  \"Java,Python,C++...(公共分类列表)\"  endl; } void content() { cout  \"C++学科视频\"  endl; } }; void test01() { //Java页面 \tcout  \"Java下载视频页面如下： \"  endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout  \"--------------------\"  endl; //Python页面 \tcout  \"Python下载视频页面如下： \"  endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout  \"--------------------\"  endl; //C++页面 \tcout  \"C++下载视频页面如下： \"  endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); } int main() { test01(); system(\"pause\"); return 0; } 继承实现：\n//公共页面 class BasePage { public: void header() { cout  \"首页、公开课、登录、注册...（公共头部）\"  endl; } void footer() { cout  \"帮助中心、交流合作、站内地图...(公共底部)\"  endl; } void left() { cout  \"Java,Python,C++...(公共分类列表)\"  endl; } }; //Java页面 class Java : public BasePage { public: void content() { cout  \"JAVA学科视频\"  endl; } }; //Python页面 class Python : public BasePage { public: void content() { cout  \"Python学科视频\"  endl; } }; //C++页面 class CPP : public BasePage { public: void content() { cout  \"C++学科视频\"  endl; } }; void test01() { //Java页面 \tcout  \"Java下载视频页面如下： \"  endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout  \"--------------------\"  endl; //Python页面 \tcout  \"Python下载视频页面如下： \"  endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout  \"--------------------\"  endl; //C++页面 \tcout  \"C++下载视频页面如下： \"  endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); } int main() { test01(); system(\"pause\"); return 0; } 总结：\n继承的好处：==可以减少重复的代码==\nclass A : public B;\nA 类称为子类 或 派生类\nB 类称为父类 或 基类\n派生类中的成员，包含两大部分：\n一类是从基类继承过来的，一类是自己增加的成员。\n从基类继承过过来的表现其共性，而新增的成员体现了其个性。\n4.6.2 继承方式 继承的语法：class 子类 : 继承方式 父类\n继承方式一共有三种：\n 公共继承 保护继承 私有继承  img\n示例：\nclass Base1 { public: int m_A; protected: int m_B; private: int m_C; }; //公共继承 class Son1 :public Base1 { public: void func() { m_A; //可访问 public权限 \tm_B; //可访问 protected权限 \t//m_C; //不可访问 \t} }; void myClass() { Son1 s1; s1.m_A; //其他类只能访问到公共权限 } //保护继承 class Base2 { public: int m_A; protected: int m_B; private: int m_C; }; class Son2:protected Base2 { public: void func() { m_A; //可访问 protected权限 \tm_B; //可访问 protected权限 \t//m_C; //不可访问 \t} }; void myClass2() { Son2 s; //s.m_A; //不可访问 } //私有继承 class Base3 { public: int m_A; protected: int m_B; private: int m_C; }; class Son3:private Base3 { public: void func() { m_A; //可访问 private权限 \tm_B; //可访问 private权限 \t//m_C; //不可访问 \t} }; class GrandSon3 :public Son3 { public: void func() { //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 \t//m_A; \t//m_B; \t//m_C; \t} }; ​```#### 4.6.3 继承中的对象模型 **问题：**从父类继承过来的成员，哪些属于子类对象中？ *示例：* ​```C++ class Base { public: int m_A; protected: int m_B; private: int m_C; //私有成员只是被隐藏了，但是还是会继承下去 }; //公共继承 class Son :public Base { public: int m_D; }; void test01() { cout  \"sizeof Son = \"  sizeof(Son)  endl; } int main() { test01(); system(\"pause\"); return 0; } 利用工具查看：\n1545881904150\n打开工具窗口后，定位到当前CPP文件的盘符\n然后输入： cl /d1 reportSingleClassLayout查看的类名 所属文件名\n效果如下图：\n1545882158050\n 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到#### 4.6.4 继承中构造和析构顺序 子类继承父类后，当创建子类对象，也会调用父类的构造函数\n 问题：父类和子类的构造和析构顺序是谁先谁后？\n示例：\nclass Base { public: Base() { cout  \"Base构造函数!\"  endl; } ~Base() { cout  \"Base析构函数!\"  endl; } }; class Son : public Base { public: Son() { cout  \"Son构造函数!\"  endl; } ~Son() { cout  \"Son析构函数!\"  endl; } }; void test01() { //继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 \tSon s; } int main() { test01(); system(\"pause\"); return 0; } ​``` 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反#### 4.6.5 继承同名成员处理方式 问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？ * 访问子类同名成员 直接访问即可 * 访问父类同名成员 需要加作用域 *示例：* ​```C++ class Base { public: Base() { m_A = 100; } void func() { cout  \"Base - func()调用\"  endl; } void func(int a) { cout  \"Base - func(int a)调用\"  endl; } public: int m_A; }; class Son : public Base { public: Son() { m_A = 200; } //当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 \t//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 \tvoid func() { cout  \"Son - func()调用\"  endl; } public: int m_A; }; void test01() { Son s; cout  \"Son下的m_A = \"  s.m_A  endl; cout  \"Base下的m_A = \"  s.Base::m_A  endl; s.func(); s.Base::func(); s.Base::func(10); } int main() { test01(); system(\"pause\"); return EXIT_SUCCESS; } 总结：\n 子类对象可以直接访问到子类中同名成员 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数  4.6.6 继承同名静态成员处理方式 问题：继承中同名的静态成员在子类对象上如何进行访问？\n静态成员和非静态成员出现同名，处理方式一致\n 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域  示例：\nclass Base { public: static void func() { cout  \"Base - static void func()\"  endl; } static void func(int a) { cout  \"Base - static void func(int a)\"  endl; } static int m_A; }; int Base::m_A = 100; class Son : public Base { public: static void func() { cout  \"Son - static void func()\"  endl; } static int m_A; }; int Son::m_A = 200; //同名成员属性 void test01() { //通过对象访问 \tcout  \"通过对象访问： \"  endl; Son s; cout  \"Son 下 m_A = \"  s.m_A  endl; cout  \"Base 下 m_A = \"  s.Base::m_A  endl; //通过类名访问 \tcout  \"通过类名访问： \"  endl; cout  \"Son 下 m_A = \"  Son::m_A  endl; cout  \"Base 下 m_A = \"  Son::Base::m_A  endl; } //同名成员函数 void test02() { //通过对象访问 \tcout  \"通过对象访问： \"  endl; Son s; s.func(); s.Base::func(); cout  \"通过类名访问： \"  endl; Son::func(); Son::Base::func(); //出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问 \tSon::Base::func(100); } int main() { //test01(); \ttest02(); system(\"pause\"); return 0; } ​``` 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）#### 4.6.7 多继承语法 C++允许*一个类继承多个类* 语法：` class 子类 ：继承方式 父类1 ， 继承方式 父类2...` 多继承可能会引发父类中有同名成员出现，需要加作用域区分 *C++实际开发中不建议用多继承* *示例：* ​```C++ class Base1 { public: Base1() { m_A = 100; } public: int m_A; }; class Base2 { public: Base2() { m_A = 200; //开始是m_B 不会出问题，但是改为mA就会出现不明确 \t} public: int m_A; }; //语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 { public: Son() { m_C = 300; m_D = 400; } public: int m_C; int m_D; }; //多继承容易产生成员同名的情况 //通过使用类名作用域可以区分调用哪一个基类的成员 void test01() { Son s; cout  \"sizeof Son = \"  sizeof(s)  endl; cout  s.Base1::m_A  endl; cout  s.Base2::m_A  endl; } int main() { test01(); system(\"pause\"); return 0; } ​``` 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域#### 4.6.8 菱形继承 *菱形继承概念：* 两个派生类继承同一个基类 又有某个类同时继承者两个派生类 这种继承被称为菱形继承，或者钻石继承 *典型的菱形继承案例：* IMG_256 *菱形继承问题：* 1. ``` 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。   草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。\n示例：\nclass Animal { public: int m_Age; }; //继承前加virtual关键字后，变为虚继承 //此时公共的父类Animal称为虚基类 class Sheep : virtual public Animal {}; class Tuo : virtual public Animal {}; class SheepTuo : public Sheep, public Tuo {}; void test01() { SheepTuo st; st.Sheep::m_Age = 100; st.Tuo::m_Age = 200; cout  \"st.Sheep::m_Age = \"  st.Sheep::m_Age  endl; cout  \"st.Tuo::m_Age = \"  st.Tuo::m_Age  endl; cout  \"st.m_Age = \"  st.m_Age  endl; } int main() { test01(); system(\"pause\"); return 0; } 总结：\n 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题  4.7 多态 4.7.1 多态的基本概念 多态是C++面向对象三大特性之一\n多态分为两类\n 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态  静态多态和动态多态区别：\n 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址  下面通过案例进行讲解多态\nclass Animal { public: //Speak函数就是虚函数 \t//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 \tvirtual void speak() { cout  \"动物在说话\"  endl; } }; class Cat :public Animal { public: void speak() { cout  \"小猫在说话\"  endl; } }; class Dog :public Animal { public: void speak() { cout  \"小狗在说话\"  endl; } }; //我们希望传入什么对象，那么就调用什么对象的函数 //如果函数地址在编译阶段就能确定，那么静态联编 //如果函数地址在运行阶段才能确定，就是动态联编  void DoSpeak(Animal \u0026 animal) { animal.speak(); } // //多态满足条件： //1、有继承关系 //2、子类重写父类中的虚函数 //多态使用： //父类指针或引用指向子类对象  void test01() { Cat cat; DoSpeak(cat); Dog dog; DoSpeak(dog); } int main() { test01(); system(\"pause\"); return 0; } 总结：\n多态满足条件\n 有继承关系 子类重写父类中的虚函数  多态使用条件\n 父类指针或引用指向子类对象  重写：函数返回值类型 函数名 参数列表 完全一致称为重写\n4.7.2 多态案例一-计算器类 案例描述：\n分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类\n多态的优点：\n 代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护  示例：\n//普通实现 class Calculator { public: int getResult(string oper) { if (oper == \"+\") { return m_Num1 + m_Num2; } else if (oper == \"-\") { return m_Num1 - m_Num2; } else if (oper == \"*\") { return m_Num1 * m_Num2; } //如果要提供新的运算，需要修改源码 \t} public: int m_Num1; int m_Num2; }; void test01() { //普通实现测试 \tCalculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout  c.m_Num1  \" + \"  c.m_Num2  \" = \"  c.getResult(\"+\")  endl; cout  c.m_Num1  \" - \"  c.m_Num2  \" = \"  c.getResult(\"-\")  endl; cout  c.m_Num1  \" * \"  c.m_Num2  \" = \"  c.getResult(\"*\")  endl; } //多态实现 //抽象计算器类 //多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护 class AbstractCalculator { public : virtual int getResult() { return 0; } int m_Num1; int m_Num2; }; //加法计算器 class AddCalculator :public AbstractCalculator { public: int getResult() { return m_Num1 + m_Num2; } }; //减法计算器 class SubCalculator :public AbstractCalculator { public: int getResult() { return m_Num1 - m_Num2; } }; //乘法计算器 class MulCalculator :public AbstractCalculator { public: int getResult() { return m_Num1 * m_Num2; } }; void test02() { //创建加法计算器 \tAbstractCalculator *abc = new AddCalculator; abc-m_Num1 = 10; abc-m_Num2 = 10; cout  abc-m_Num1  \" + \"  abc-m_Num2  \" = \"  abc-getResult()  endl; delete abc; //用完了记得销毁  //创建减法计算器 \tabc = new SubCalculator; abc-m_Num1 = 10; abc-m_Num2 = 10; cout  abc-m_Num1  \" - \"  abc-m_Num2  \" = \"  abc-getResult()  endl; delete abc; //创建乘法计算器 \tabc = new MulCalculator; abc-m_Num1 = 10; abc-m_Num2 = 10; cout  abc-m_Num1  \" * \"  abc-m_Num2  \" = \"  abc-getResult()  endl; delete abc; } int main() { //test01();  test02(); system(\"pause\"); return 0; } ​``` 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多#### 4.7.3 纯虚函数和抽象类 在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为*纯虚函数* 纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;` 当类中有了纯虚函数，这个类也称为==抽象类== *抽象类特点*： * 无法实例化对象 * 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 *示例：* ​```C++ class Base { public: //纯虚函数 \t//类中只要有一个纯虚函数就称为抽象类 \t//抽象类无法实例化对象 \t//子类必须重写父类中的纯虚函数，否则也属于抽象类 \tvirtual void func() = 0; }; class Son :public Base { public: virtual void func() { cout  \"func调用\"  endl; }; }; void test01() { Base * base = NULL; //base = new Base; // 错误，抽象类无法实例化对象 \tbase = new Son; base-func(); delete base;//记得销毁 } int main() { test01(); system(\"pause\"); return 0; } ​```#### 4.7.4 多态案例二-制作饮品 *案例描述：* 制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶 1545985945198 *示例：* ​```C++ //抽象制作饮品 class AbstractDrinking { public: //烧水 \tvirtual void Boil() = 0; //冲泡 \tvirtual void Brew() = 0; //倒入杯中 \tvirtual void PourInCup() = 0; //加入辅料 \tvirtual void PutSomething() = 0; //规定流程 \tvoid MakeDrink() { Boil(); Brew(); PourInCup(); PutSomething(); } }; //制作咖啡 class Coffee : public AbstractDrinking { public: //烧水 \tvirtual void Boil() { cout  \"煮农夫山泉!\"  endl; } //冲泡 \tvirtual void Brew() { cout  \"冲泡咖啡!\"  endl; } //倒入杯中 \tvirtual void PourInCup() { cout  \"将咖啡倒入杯中!\"  endl; } //加入辅料 \tvirtual void PutSomething() { cout  \"加入牛奶!\"  endl; } }; //制作茶水 class Tea : public AbstractDrinking { public: //烧水 \tvirtual void Boil() { cout  \"煮自来水!\"  endl; } //冲泡 \tvirtual void Brew() { cout  \"冲泡茶叶!\"  endl; } //倒入杯中 \tvirtual void PourInCup() { cout  \"将茶水倒入杯中!\"  endl; } //加入辅料 \tvirtual void PutSomething() { cout  \"加入枸杞!\"  endl; } }; //业务函数 void DoWork(AbstractDrinking* drink) { drink-MakeDrink(); delete drink; } void test01() { DoWork(new Coffee); cout  \"--------------\"  endl; DoWork(new Tea); } int main() { test01(); system(\"pause\"); return 0; } ​```#### 4.7.5 虚析构和纯虚析构 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为*虚析构*或者*纯虚析构* 虚析构和纯虚析构共性： * 可以解决父类指针释放子类对象 * 都需要有具体的函数实现 虚析构和纯虚析构区别： * 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法： `virtual ~类名(){}` 纯虚析构语法： ` virtual ~类名() = 0;` `类名::~类名(){}` *示例：* ​```C++ class Animal { public: Animal() { cout  \"Animal 构造函数调用！\"  endl; } virtual void Speak() = 0; //析构函数加上virtual关键字，变成虚析构函数 \t//virtual ~Animal() \t//{ \t//\tcout \t//}  virtual ~Animal() = 0; }; Animal::~Animal() { cout  \"Animal 纯虚析构函数调用！\"  endl; } //和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。  class Cat : public Animal { public: Cat(string name) { cout  \"Cat构造函数调用！\"  endl; m_Name = new string(name); } virtual void Speak() { cout  *m_Name  \"小猫在说话!\"  endl; } ~Cat() { cout  \"Cat析构函数调用!\"  endl; if (this-m_Name != NULL) { delete m_Name; m_Name = NULL; } } public: string *m_Name; }; void test01() { Animal *animal = new Cat(\"Tom\"); animal-Speak(); //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 \t//怎么解决？给基类增加一个虚析构函数 \t//虚析构函数就是用来解决通过父类指针释放子类对象 \tdelete animal; } int main() { test01(); system(\"pause\"); return 0; } 总结：\n1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 3. 拥有纯虚析构函数的类也属于抽象类  4.7.6 多态案例三-电脑组装 案例描述：\n电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）\n将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商\n创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口\n测试时组装三台不同的电脑进行工作\n示例：\n#includeusing namespace std; //抽象CPU类 class CPU { public: //抽象的计算函数 \tvirtual void calculate() = 0; }; //抽象显卡类 class VideoCard { public: //抽象的显示函数 \tvirtual void display() = 0; }; //抽象内存条类 class Memory { public: //抽象的存储函数 \tvirtual void storage() = 0; }; //电脑类 class Computer { public: Computer(CPU * cpu, VideoCard * vc, Memory * mem) { m_cpu = cpu; m_vc = vc; m_mem = mem; } //提供工作的函数 \tvoid work() { //让零件工作起来，调用接口 \tm_cpu-calculate(); m_vc-display(); m_mem-storage(); } //提供析构函数 释放3个电脑零件 \t~Computer() { //释放CPU零件 \tif (m_cpu != NULL) { delete m_cpu; m_cpu = NULL; } //释放显卡零件 \tif (m_vc != NULL) { delete m_vc; m_vc = NULL; } //释放内存条零件 \tif (m_mem != NULL) { delete m_mem; m_mem = NULL; } } private: CPU * m_cpu; //CPU的零件指针 \tVideoCard * m_vc; //显卡零件指针 \tMemory * m_mem; //内存条零件指针 }; //具体厂商 //Intel厂商 class IntelCPU :public CPU { public: virtual void calculate() { cout  \"Intel的CPU开始计算了！\"  endl; } }; class IntelVideoCard :public VideoCard { public: virtual void display() { cout  \"Intel的显卡开始显示了！\"  endl; } }; class IntelMemory :public Memory { public: virtual void storage() { cout  \"Intel的内存条开始存储了！\"  endl; } }; //Lenovo厂商 class LenovoCPU :public CPU { public: virtual void calculate() { cout  \"Lenovo的CPU开始计算了！\"  endl; } }; class LenovoVideoCard :public VideoCard { public: virtual void display() { cout  \"Lenovo的显卡开始显示了！\"  endl; } }; class LenovoMemory :public Memory { public: virtual void storage() { cout  \"Lenovo的内存条开始存储了！\"  endl; } }; void test01() { //第一台电脑零件 \tCPU * intelCpu = new IntelCPU; VideoCard * intelCard = new IntelVideoCard; Memory * intelMem = new IntelMemory; cout  \"第一台电脑开始工作：\"  endl; //创建第一台电脑 \tComputer * computer1 = new Computer(intelCpu, intelCard, intelMem); computer1-work(); delete computer1; cout  \"-----------------------\"  endl; cout  \"第二台电脑开始工作：\"  endl; //第二台电脑组装 \tComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);; computer2-work(); delete computer2; cout  \"-----------------------\"  endl; cout  \"第三台电脑开始工作：\"  endl; //第三台电脑组装 \tComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);; computer3-work(); delete computer3; } ​```## 5 文件操作 程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过*文件可以将数据持久化* C++中对文件操作需要包含头文件 == fstream == 文件类型分为两种： 1. *文本文件* - 文件以文本的*ASCII码*形式存储在计算机中 2. *二进制文件* - 文件以文本的*二进制*形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类: 1. ofstream：写操作 2. ifstream： 读操作 3. fstream ： 读写操作 ### 5.1文本文件 #### 5.1.1写文件 写文件步骤如下： 1. 包含头文件 #include  2. 创建流对象 ofstream ofs; 3. 打开文件 ofs.open(\"文件路径\",打开方式); 4. 写数据 ofs  \"写入的数据\"; 5. 关闭文件 ofs.close(); 文件打开方式： | 打开方式 | 解释 | | ----------- | -------------------------- | | ios::in | 为读文件而打开文件 | | ios::out | 为写文件而打开文件 | | ios::ate | 初始位置：文件尾 | | ios::app | 追加方式写文件 | | ios::trunc | 如果文件存在先删除，再创建 | | ios::binary | 二进制方式 | *注意：* 文件打开方式可以配合使用，利用|操作符 **例如：**用二进制方式写文件 `ios::binary | ios:: out` *示例：* ​```C++ #include  void test01() { ofstream ofs; ofs.open(\"test.txt\", ios::out); ofs  \"姓名：张三\"  endl; ofs  \"性别：男\"  endl; ofs  \"年龄：18\"  endl; ofs.close(); } int main() { test01(); system(\"pause\"); return 0; } 总结：\n 文件操作必须包含头文件 fstream 读文件可以利用 ofstream ，或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用«可以向文件中写数据 操作完毕，要关闭文件  5.1.2读文件 读文件与写文件步骤相似，但是读取方式相对于比较多\n读文件步骤如下： 1. 包含头文件\n#include   创建流对象\nifstream ifs;\n  打开文件并判断文件是否打开成功\nifs.open(“文件路径”,打开方式);\n  读数据\n四种方式读取\n  关闭文件\nifs.close();\n示例：\n#include #include void test01() { ifstream ifs; ifs.open(\"test.txt\", ios::in); if (!ifs.is_open()) { cout  \"文件打开失败\"  endl; return; } //第一种方式 \t//char buf[1024] = { 0 }; \t//while (ifs  buf) \t//{ \t//\tcout \t//}  //第二种 \t//char buf[1024] = { 0 }; \t//while (ifs.getline(buf,sizeof(buf))) \t//{ \t//\tcout \t//}  //第三种 \t//string buf; \t//while (getline(ifs, buf)) \t//{ \t//\tcout \t//}  char c; while ((c = ifs.get()) != EOF) { cout  c; } ifs.close(); } int main() { test01(); system(\"pause\"); return 0; } 总结：\n 读文件可以利用 ifstream ，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件  5.2 二进制文件 以二进制的方式对文件进行读写操作\n打开方式要指定为 ==ios::binary==\n5.2.1 写文件 二进制方式写文件主要利用流对象调用成员函数write\n函数原型 ：ostream\u0026 write(const char * buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n#include #include  class Person { public: char m_Name[64]; int m_Age; }; //二进制文件 写文件 void test01() { //1、包含头文件  //2、创建输出流对象 \tofstream ofs(\"person.txt\", ios::out | ios::binary); //3、打开文件 \t//ofs.open(\"person.txt\", ios::out | ios::binary);  Person p = {\"张三\" , 18}; //4、写文件 \tofs.write((const char *)\u0026p, sizeof(p)); //5、关闭文件 \tofs.close(); } int main() { test01(); system(\"pause\"); return 0; } 总结：\n 文件输出流对象 可以通过write函数，以二进制方式写数据  5.2.2 读文件 二进制方式读文件主要利用流对象调用成员函数read\n函数原型：istream\u0026 read(char *buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n#include #include  class Person { public: char m_Name[64]; int m_Age; }; void test01() { ifstream ifs(\"person.txt\", ios::in | ios::binary); if (!ifs.is_open()) { cout  \"文件打开失败\"  endl; } Person p; ifs.read((char *)\u0026p, sizeof(p)); cout  \"姓名： \"  p.m_Name  \" 年龄： \"  p.m_Age  endl; } int main() { test01(); system(\"pause\"); return 0; } ​```* 文件输入流对象 可以通过read函数，以二进制方式读数据 ",
  "wordCount" : "6673",
  "inLanguage": "en",
  "datePublished": "2021-09-20T16:56:33+08:00",
  "dateModified": "2021-09-20T16:56:33+08:00",
  "author":{
    "@type": "Person",
    "name": "Me"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://github.com/FreanJa/freanja.github.io/post/blog/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "FreanJa's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://github.com/FreanJa/freanja.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://github.com/FreanJa/freanja.github.io/" accesskey="h" title="Home (Alt + H)">
                <img src="/apple-touch-icon.png" alt="logo" aria-label="logo"
                    height="35">Home</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://github.com/FreanJa/freanja.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/FreanJa/freanja.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/FreanJa/freanja.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/FreanJa/freanja.github.io/about/" title="About me">
                    <span>About me</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://github.com/FreanJa/freanja.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://github.com/FreanJa/freanja.github.io/post/">Posts</a></div>
    <h1 class="post-title">
      C&#43;&#43;核心编程<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h1>
    <div class="post-meta">September 20, 2021&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me
</div>
  </header> 
  <div class="post-content"><h1 id="heading"><a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h1>
<p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<h2 id="1-内存分区模型">1 内存分区模型<a hidden class="anchor" aria-hidden="true" href="#1-内存分区模型">#</a></h2>
<p>C++程序在执行时，将内存大方向划分为<em>4个区域</em></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><em>内存四区意义：</em></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="11-程序运行前">1.1 程序运行前<a hidden class="anchor" aria-hidden="true" href="#11-程序运行前">#</a></h3>
<pre><code>在程序编译后，生成了exe可执行程序，*未执行该程序前*分为两个区域

*代码区：*

	存放 CPU 执行的机器指令

	代码区是*共享*的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

	代码区是*只读*的，使其只读的原因是防止程序意外地修改了它的指令

*全局区：*

	全局变量和静态变量存放在此.

	全局区还包含了常量区, 字符串常量和其他常量也存放在此.

	==该区域的数据在程序结束后由操作系统释放==.
</code></pre>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//全局变量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> g_a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
<span style="color:#66d9ef">int</span> g_b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

<span style="color:#75715e">//全局常量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> c_g_a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> c_g_b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#75715e">//局部变量
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	<span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

	<span style="color:#75715e">//打印地址
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;局部变量a地址为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>a <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;局部变量b地址为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>b <span style="color:#f92672">&lt;&lt;</span> endl;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;全局变量g_a地址为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span>  (<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>g_a <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;全局变量g_b地址为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span>  (<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>g_b <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//静态变量
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> s_a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> s_b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;静态变量s_a地址为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>s_a <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;静态变量s_b地址为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>s_b <span style="color:#f92672">&lt;&lt;</span> endl;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;字符串常量地址为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span><span style="color:#e6db74">&#34;hello world&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;字符串常量地址为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span><span style="color:#e6db74">&#34;hello world1&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;全局常量c_g_a地址为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>c_g_a <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;全局常量c_g_b地址为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>c_g_b <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> c_l_a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> c_l_b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;局部常量c_l_a地址为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>c_l_a <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;局部常量c_l_b地址为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&amp;</span>c_l_b <span style="color:#f92672">&lt;&lt;</span> endl;

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>打印结果：</p>
<p>1545017602518</p>
<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
</ul>
<h3 id="12-程序运行后">1.2 程序运行后<a hidden class="anchor" aria-hidden="true" href="#12-程序运行后">#</a></h3>
<pre><code>*栈区：*

	由编译器自动分配释放, 存放函数的参数值,局部变量等

	注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放
</code></pre>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">func</span>()
{
	<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>a;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> func();

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">&lt;&lt;</span> endl;

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><pre><code>*堆区：*

	由程序员分配释放,若程序员不释放,程序结束时由操作系统回收

	在C++中主要利用new在堆区开辟内存
</code></pre>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">func</span>()
{
	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">10</span>);
	<span style="color:#66d9ef">return</span> a;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> func();

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">&lt;&lt;</span> endl;
    
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><em>总结：</em></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="13-new操作符">1.3 new操作符<a hidden class="anchor" aria-hidden="true" href="#13-new操作符">#</a></h3>
<pre><code>C++中利用==new==操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==

语法：` new 数据类型`

利用new创建的数据，会返回该数据对应的类型的指针
</code></pre>
<p><em>示例1： 基本语法</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">func</span>()
{
	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">10</span>);
	<span style="color:#66d9ef">return</span> a;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> func();

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//利用delete释放堆区数据
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">delete</span> p;

	<span style="color:#75715e">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问
</span><span style="color:#75715e"></span>
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><em>示例2：开辟数组</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//堆区开辟数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">10</span>];

	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>)
	{
		arr[i] <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">100</span>;
	}

	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>)
	{
		cout <span style="color:#f92672">&lt;&lt;</span> arr[i] <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//释放数组 delete 后加 []
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">delete</span>[] arr;

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#960050;background-color:#1e0010">​```##</span> <span style="color:#ae81ff">2</span> <span style="color:#960050;background-color:#1e0010">引用</span>
<span style="color:#75715e">### 2.1 引用的基本使用
</span><span style="color:#75715e"></span><span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">作用：</span> <span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">给变量起别名</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">语法：</span><span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">`数据类型</span> <span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">别名</span> <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">原名`</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">int</span> main() {

	<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b <span style="color:#f92672">=</span> a;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;b = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> endl;

	b <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;b = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> endl;

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```###</span> <span style="color:#ae81ff">2.2</span> <span style="color:#960050;background-color:#1e0010">引用注意事项</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">引用必须初始化</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">引用在初始化后，不可以改变</span>

<span style="color:#960050;background-color:#1e0010">示例：</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">int</span> main() {

	<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	<span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
	<span style="color:#75715e">//int &amp;c; //错误，引用必须初始化
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>c <span style="color:#f92672">=</span> a; <span style="color:#75715e">//一旦初始化后，就不可以更改
</span><span style="color:#75715e"></span>	c <span style="color:#f92672">=</span> b; <span style="color:#75715e">//这是赋值操作，不是更改引用
</span><span style="color:#75715e"></span>
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;b = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;c = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c <span style="color:#f92672">&lt;&lt;</span> endl;

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```###</span> <span style="color:#ae81ff">2.3</span> <span style="color:#960050;background-color:#1e0010">引用做函数参数</span>
<span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">作用：</span><span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">函数传参时，可以利用引用的技术让形参修饰实参</span>

<span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">优点：</span><span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">可以简化指针修改实参</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#75715e">//1. 值传递
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> mySwap01(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
	<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> a;
	a <span style="color:#f92672">=</span> b;
	b <span style="color:#f92672">=</span> temp;
}

<span style="color:#75715e">//2. 地址传递
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mySwap02</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> a, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> b) {
	<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>a;
	<span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>b;
	<span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> temp;
}

<span style="color:#75715e">//3. 引用传递
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mySwap03</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> b) {
	<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> a;
	a <span style="color:#f92672">=</span> b;
	b <span style="color:#f92672">=</span> temp;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	<span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;

	mySwap01(a, b);
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; b:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> endl;

	mySwap02(<span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b);
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; b:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> endl;

	mySwap03(a, b);
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; b:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> endl;

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#960050;background-color:#1e0010">​```</span><span style="color:#f92672">&gt;</span> <span style="color:#960050;background-color:#1e0010">总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单###</span> <span style="color:#ae81ff">2.4</span> <span style="color:#960050;background-color:#1e0010">引用做函数返回值</span>
<span style="color:#960050;background-color:#1e0010">作用：引用是可以作为函数的返回值存在的</span>

<span style="color:#960050;background-color:#1e0010">注意：</span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">不要返回局部变量引用</span><span style="color:#f92672">*</span>

<span style="color:#960050;background-color:#1e0010">用法：函数调用作为左值</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#75715e">//返回局部变量引用
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> test01() {
	<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">//局部变量
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> a;
}

<span style="color:#75715e">//返回静态变量引用
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> test02() {
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
	<span style="color:#66d9ef">return</span> a;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#75715e">//不能返回局部变量的引用
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> ref <span style="color:#f92672">=</span> test01();
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ref = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ref <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ref = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ref <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//如果函数做左值，那么必须返回引用
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> ref2 <span style="color:#f92672">=</span> test02();
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ref2 = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ref2 <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ref2 = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ref2 <span style="color:#f92672">&lt;&lt;</span> endl;

	test02() <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ref2 = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ref2 <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ref2 = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ref2 <span style="color:#f92672">&lt;&lt;</span> endl;

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="25-引用的本质">2.5 引用的本质<a hidden class="anchor" aria-hidden="true" href="#25-引用的本质">#</a></h3>
<p>本质：<em>引用的本质在c++内部实现是一个指针常量.</em></p>
<p>讲解示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//发现是引用，转换为 int* const ref = &amp;a;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> ref){
	ref <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>; <span style="color:#75715e">// ref是引用，转换为*ref = 100
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
	<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
    
    <span style="color:#75715e">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> ref <span style="color:#f92672">=</span> a; 
	ref <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>; <span style="color:#75715e">//内部发现ref是引用，自动帮我们转换为: *ref = 20;
</span><span style="color:#75715e"></span>    
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ref:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> ref <span style="color:#f92672">&lt;&lt;</span> endl;
    
	func(a);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="26-常量引用">2.6 常量引用<a hidden class="anchor" aria-hidden="true" href="#26-常量引用">#</a></h3>
<p>**作用：**常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//引用使用的场景，通常用来修饰形参
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">showValue</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> v) {
	<span style="color:#75715e">//v += 10;
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> v <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#75715e">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> ref <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

	<span style="color:#75715e">//ref = 100;  //加入const后不可以修改变量
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> ref <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//函数中利用常量引用防止误操作修改实参
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	showValue(a);

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```##</span> <span style="color:#ae81ff">3</span> <span style="color:#960050;background-color:#1e0010">函数提高</span>
<span style="color:#75715e">### 3.1 函数默认参数
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">在</span>C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">中，函数的形参列表中的形参是可以有默认值的。</span>

<span style="color:#960050;background-color:#1e0010">语法：`</span> <span style="color:#960050;background-color:#1e0010">返回值类型</span>  <span style="color:#960050;background-color:#1e0010">函数名</span> <span style="color:#960050;background-color:#1e0010">（参数</span><span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">默认值）</span>{}<span style="color:#960050;background-color:#1e0010">`</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">int</span> func(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>, <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>) {
	<span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b <span style="color:#f92672">+</span> c;
}

<span style="color:#75715e">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值
</span><span style="color:#75715e">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">func2</span>(<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>, <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>);
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">func2</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
	<span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ret = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> func(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">20</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ret = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> func(<span style="color:#ae81ff">100</span>) <span style="color:#f92672">&lt;&lt;</span> endl;

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```###</span> <span style="color:#ae81ff">3.2</span> <span style="color:#960050;background-color:#1e0010">函数占位参数</span>
C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">语法：</span><span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">`返回值类型</span> <span style="color:#960050;background-color:#1e0010">函数名</span> (<span style="color:#960050;background-color:#1e0010">数据类型</span>){}<span style="color:#960050;background-color:#1e0010">`</span>

<span style="color:#960050;background-color:#1e0010">在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#75715e">//函数占位参数 ，占位参数也可以有默认参数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> func(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span>) {
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;this is func&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	func(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">10</span>); <span style="color:#75715e">//占位参数必须填补
</span><span style="color:#75715e"></span>
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```###</span> <span style="color:#ae81ff">3.3</span> <span style="color:#960050;background-color:#1e0010">函数重载</span>
<span style="color:#75715e">#### 3.3.1 函数重载概述
</span><span style="color:#75715e"></span><span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">作用：</span><span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">函数名可以相同，提高复用性</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">函数重载满足条件：</span><span style="color:#f92672">*</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">同一个作用域下</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">函数名称相同</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">函数参数</span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">类型不同</span><span style="color:#f92672">*</span>  <span style="color:#960050;background-color:#1e0010">或者</span> <span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">个数不同</span><span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">或者</span> <span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">顺序不同</span><span style="color:#f92672">*</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">注意</span><span style="color:#f92672">:*</span>  <span style="color:#960050;background-color:#1e0010">函数的返回值不可以作为函数重载的条件</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#75715e">//函数重载需要函数都在同一个作用域下
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> func()
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;func 的调用！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(<span style="color:#66d9ef">int</span> a)
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;func (int a) 的调用！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(<span style="color:#66d9ef">double</span> a)
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;func (double a)的调用！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(<span style="color:#66d9ef">int</span> a ,<span style="color:#66d9ef">double</span> b)
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;func (int a ,double b) 的调用！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(<span style="color:#66d9ef">double</span> a ,<span style="color:#66d9ef">int</span> b)
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;func (double a ,int b)的调用！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#75715e">//函数返回值不可以作为函数重载条件
</span><span style="color:#75715e">//int func(double a, int b)
</span><span style="color:#75715e">//{
</span><span style="color:#75715e">//	cout &lt;&lt; &#34;func (double a ,int b)的调用！&#34; &lt;&lt; endl;
</span><span style="color:#75715e">//}
</span><span style="color:#75715e"></span>

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	func();
	func(<span style="color:#ae81ff">10</span>);
	func(<span style="color:#ae81ff">3.14</span>);
	func(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">3.14</span>);
	func(<span style="color:#ae81ff">3.14</span> , <span style="color:#ae81ff">10</span>);
	
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">3.3.2</span> <span style="color:#960050;background-color:#1e0010">函数重载注意事项</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">引用作为重载条件</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">函数重载碰到函数默认参数</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#75715e">//函数重载注意事项
</span><span style="color:#75715e">//1、引用作为重载条件
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> func(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a)
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;func (int &amp;a) 调用 &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a)
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;func (const int &amp;a) 调用 &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}


<span style="color:#75715e">//2、函数重载碰到函数默认参数
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func2</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>)
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;func2(int a, int b = 10) 调用&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func2</span>(<span style="color:#66d9ef">int</span> a)
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;func2(int a) 调用&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	
	<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	func(a); <span style="color:#75715e">//调用无const
</span><span style="color:#75715e"></span>	func(<span style="color:#ae81ff">10</span>);<span style="color:#75715e">//调用有const
</span><span style="color:#75715e"></span>

	<span style="color:#75715e">//func2(10); //碰到默认参数产生歧义，需要避免
</span><span style="color:#75715e"></span>
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```##</span> <span style="color:#f92672">*</span><span style="color:#ae81ff">4</span><span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">类和对象</span>
C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">面向对象的三大特性为：</span><span style="color:#f92672">==</span><span style="color:#960050;background-color:#1e0010">封装、继承、多态</span><span style="color:#f92672">==</span>

C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">认为</span><span style="color:#f92672">==</span><span style="color:#960050;background-color:#1e0010">万事万物都皆为对象</span><span style="color:#f92672">==</span><span style="color:#960050;background-color:#1e0010">，对象上有其属性和行为</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">例如：</span><span style="color:#f92672">*</span>

	<span style="color:#960050;background-color:#1e0010">人可以作为对象，属性有姓名、年龄、身高、体重</span>...<span style="color:#960050;background-color:#1e0010">，行为有走、跑、跳、吃饭、唱歌</span>...

	<span style="color:#960050;background-color:#1e0010">车也可以作为对象，属性有轮胎、方向盘、车灯</span>...,<span style="color:#960050;background-color:#1e0010">行为有载人、放音乐、放空调</span>...

	<span style="color:#960050;background-color:#1e0010">具有相同性质的</span><span style="color:#f92672">==</span><span style="color:#960050;background-color:#1e0010">对象</span><span style="color:#f92672">==</span><span style="color:#960050;background-color:#1e0010">，我们可以抽象称为</span><span style="color:#f92672">==</span><span style="color:#960050;background-color:#1e0010">类</span><span style="color:#f92672">==</span><span style="color:#960050;background-color:#1e0010">，人属于人类，车属于车类</span>
<span style="color:#75715e">### 4.1 封装
</span><span style="color:#75715e">#### 4.1.1  封装的意义
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">封装是</span>C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">面向对象三大特性之一</span>

<span style="color:#960050;background-color:#1e0010">封装的意义：</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">将属性和行为作为一个整体，表现生活中的事物</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">将属性和行为加以权限控制</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">封装意义一：</span><span style="color:#f92672">*</span>

	<span style="color:#960050;background-color:#1e0010">在设计类的时候，属性和行为写在一起，表现事物</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">语法：</span><span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">类名</span>{   <span style="color:#960050;background-color:#1e0010">访问权限：</span> <span style="color:#960050;background-color:#1e0010">属性</span>  <span style="color:#f92672">/</span> <span style="color:#960050;background-color:#1e0010">行为</span>  };<span style="color:#960050;background-color:#1e0010">`</span>

<span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">示例</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">设计一个圆类，求圆的周长</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例代码：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#75715e">//圆周率
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> PI <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;

<span style="color:#75715e">//1、封装的意义
</span><span style="color:#75715e">//将属性和行为作为一个整体，用来表现生活中的事物
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//封装一个圆类，求圆的周长
</span><span style="color:#75715e">//class代表设计一个类，后面跟着的是类名
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Circle</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>  <span style="color:#75715e">//访问权限  公共的权限
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//属性
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> m_r;<span style="color:#75715e">//半径
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//行为
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//获取到圆的周长
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">double</span> <span style="color:#a6e22e">calculateZC</span>()
	{
		<span style="color:#75715e">//2 * pi  * r
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//获取圆的周长
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span>  <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> PI <span style="color:#f92672">*</span> m_r;
	}
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#75715e">//通过圆类，创建圆的对象
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// c1就是一个具体的圆
</span><span style="color:#75715e"></span>	Circle c1;
	c1.m_r <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">//给圆对象的半径 进行赋值操作
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//2 * pi * 10 = = 62.8
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;圆的周长为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c1.calculateZC() <span style="color:#f92672">&lt;&lt;</span> endl;

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><em>示例2代码：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//学生类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> setName(string name) {
		m_name <span style="color:#f92672">=</span> name;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setID</span>(<span style="color:#66d9ef">int</span> id) {
		m_id <span style="color:#f92672">=</span> id;
	}

	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">showStudent</span>() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;name:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_name <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; ID:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_id <span style="color:#f92672">&lt;&lt;</span> endl;
	}
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	string m_name;
	<span style="color:#66d9ef">int</span> m_id;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	Student stu;
	stu.setName(<span style="color:#e6db74">&#34;德玛西亚&#34;</span>);
	stu.setID(<span style="color:#ae81ff">250</span>);
	stu.showStudent();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><p><em>封装意义二：</em></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public        公共权限</li>
<li>protected 保护权限</li>
<li>private      私有权限</li>
</ol>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//三种权限
</span><span style="color:#75715e">//公共权限  public     类内可以访问  类外可以访问
</span><span style="color:#75715e">//保护权限  protected  类内可以访问  类外不可以访问
</span><span style="color:#75715e">//私有权限  private    类内可以访问  类外不可以访问
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>
{
	<span style="color:#75715e">//姓名  公共权限
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	string m_Name;

	<span style="color:#75715e">//汽车  保护权限
</span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
	string m_Car;

	<span style="color:#75715e">//银行卡密码  私有权限
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_Password;

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> func()
	{
		m_Name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;张三&#34;</span>;
		m_Car <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;拖拉机&#34;</span>;
		m_Password <span style="color:#f92672">=</span> <span style="color:#ae81ff">123456</span>;
	}
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	Person p;
	p.m_Name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;李四&#34;</span>;
	<span style="color:#75715e">//p.m_Car = &#34;奔驰&#34;;  //保护权限类外访问不到
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//p.m_Password = 123; //私有权限类外访问不到
</span><span style="color:#75715e"></span>
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.1.2</span> struct和class区别
<span style="color:#960050;background-color:#1e0010">在</span>C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">中</span> struct和class唯一的<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">区别</span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">就在于</span> <span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">默认的访问权限不同</span><span style="color:#f92672">*</span>

<span style="color:#960050;background-color:#1e0010">区别：</span>
<span style="color:#f92672">*</span> <span style="color:#66d9ef">struct</span> <span style="color:#960050;background-color:#1e0010">默认权限为公共</span>
<span style="color:#f92672">*</span> <span style="color:#66d9ef">class</span>   <span style="color:#960050;background-color:#1e0010">默认权限为私有</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C1</span>
{
	<span style="color:#66d9ef">int</span>  m_A; <span style="color:#75715e">//默认是私有权限
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">C2</span>
{
	<span style="color:#66d9ef">int</span> m_A;  <span style="color:#75715e">//默认是公共权限
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	C1 c1;
	c1.m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">//错误，访问权限是私有
</span><span style="color:#75715e"></span>
	C2 c2;
	c2.m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">//正确，访问权限是公共
</span><span style="color:#75715e"></span>
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.1.3</span> <span style="color:#960050;background-color:#1e0010">成员属性设置为私有</span>
<span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">优点</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">将所有成员属性设置为私有，可以自己控制读写权限</span>

<span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">优点</span><span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">对于写权限，我们可以检测数据的有效性</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	<span style="color:#75715e">//姓名设置可读可写
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> setName(string name) {
		m_Name <span style="color:#f92672">=</span> name;
	}
	string <span style="color:#a6e22e">getName</span>()
	{
		<span style="color:#66d9ef">return</span> m_Name;
	}


	<span style="color:#75715e">//获取年龄 
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getAge</span>() {
		<span style="color:#66d9ef">return</span> m_Age;
	}
	<span style="color:#75715e">//设置年龄
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setAge</span>(<span style="color:#66d9ef">int</span> age) {
		<span style="color:#66d9ef">if</span> (age <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> age <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">150</span>) {
			cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;你个老妖精!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
			<span style="color:#66d9ef">return</span>;
		}
		m_Age <span style="color:#f92672">=</span> age;
	}

	<span style="color:#75715e">//情人设置为只写
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setLover</span>(string lover) {
		m_Lover <span style="color:#f92672">=</span> lover;
	}

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	string m_Name; <span style="color:#75715e">//可读可写  姓名
</span><span style="color:#75715e"></span>	
	<span style="color:#66d9ef">int</span> m_Age; <span style="color:#75715e">//只读  年龄
</span><span style="color:#75715e"></span>
	string m_Lover; <span style="color:#75715e">//只写  情人
</span><span style="color:#75715e"></span>};


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	Person p;
	<span style="color:#75715e">//姓名设置
</span><span style="color:#75715e"></span>	p.setName(<span style="color:#e6db74">&#34;张三&#34;</span>);
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;姓名： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.getName() <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//年龄设置
</span><span style="color:#75715e"></span>	p.setAge(<span style="color:#ae81ff">50</span>);
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;年龄： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.getAge() <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//情人设置
</span><span style="color:#75715e"></span>	p.setLover(<span style="color:#e6db74">&#34;苍井&#34;</span>);
	<span style="color:#75715e">//cout &lt;&lt; &#34;情人： &#34; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取
</span><span style="color:#75715e"></span>
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><em>练习案例1：设计立方体类</em></p>
<p>设计立方体类(Cube)</p>
<p>求出立方体的面积和体积</p>
<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>
<p>1545533548532</p>
<p><em>练习案例2：点和圆的关系</em></p>
<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>
<p>1545533829184</p>
<h3 id="42-对象的初始化和清理">4.2 对象的初始化和清理<a hidden class="anchor" aria-hidden="true" href="#42-对象的初始化和清理">#</a></h3>
<ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="421-构造函数和析构函数">4.2.1 构造函数和析构函数<a hidden class="anchor" aria-hidden="true" href="#421-构造函数和析构函数">#</a></h4>
<p>对象的<em>初始化和清理</em>也是两个非常重要的安全问题</p>
<pre><code>一个对象或者变量没有初始状态，对其使用后果是未知

同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题
</code></pre>
<p>c++利用了<em>构造函数</em>和<em>析构函数</em>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<em>我们不提供构造和析构，编译器会提供</em></p>
<p><em>编译器提供的构造函数和析构函数是空实现。</em></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<em>销毁前</em>系统自动调用，执行一些清理工作。</li>
</ul>
<p><em>构造函数语法：</em><code>类名(){}</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><em>析构函数语法：</em> <code>~类名(){}</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#75715e">//构造函数
</span><span style="color:#75715e"></span>	Person()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Person的构造函数调用&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//析构函数
</span><span style="color:#75715e"></span>	<span style="color:#f92672">~</span>Person()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Person的析构函数调用&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	Person p;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	
	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.2.2</span> <span style="color:#960050;background-color:#1e0010">构造函数的分类及调用</span>
<span style="color:#960050;background-color:#1e0010">两种分类方式：</span>

	<span style="color:#960050;background-color:#1e0010">按参数分为：</span> <span style="color:#960050;background-color:#1e0010">有参构造和无参构造</span>

	<span style="color:#960050;background-color:#1e0010">按类型分为：</span> <span style="color:#960050;background-color:#1e0010">普通构造和拷贝构造</span>

<span style="color:#960050;background-color:#1e0010">三种调用方式：</span>

	<span style="color:#960050;background-color:#1e0010">括号法</span>

	<span style="color:#960050;background-color:#1e0010">显示法</span>

	<span style="color:#960050;background-color:#1e0010">隐式转换法</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#75715e">//1、构造函数分类
</span><span style="color:#75715e">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数
</span><span style="color:#75715e">// 按照类型分类分为 普通构造和拷贝构造
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#75715e">//无参（默认）构造函数
</span><span style="color:#75715e"></span>	Person() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;无参构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//有参构造函数
</span><span style="color:#75715e"></span>	Person(<span style="color:#66d9ef">int</span> a) {
		age <span style="color:#f92672">=</span> a;
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;有参构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//拷贝构造函数
</span><span style="color:#75715e"></span>	Person(<span style="color:#66d9ef">const</span> Person<span style="color:#f92672">&amp;</span> p) {
		age <span style="color:#f92672">=</span> p.age;
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;拷贝构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//析构函数
</span><span style="color:#75715e"></span>	<span style="color:#f92672">~</span>Person() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;析构函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> age;
};

<span style="color:#75715e">//2、构造函数的调用
</span><span style="color:#75715e">//调用无参构造函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>() {
	Person p; <span style="color:#75715e">//调用无参构造函数
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">//调用有参的构造函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test02</span>() {

	<span style="color:#75715e">//2.1  括号法，常用
</span><span style="color:#75715e"></span>	Person p1(<span style="color:#ae81ff">10</span>);
	<span style="color:#75715e">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//Person p2();
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//2.2 显式法
</span><span style="color:#75715e"></span>	Person p2 <span style="color:#f92672">=</span> Person(<span style="color:#ae81ff">10</span>); 
	Person p3 <span style="color:#f92672">=</span> Person(p2);
	<span style="color:#75715e">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//2.3 隐式转换法
</span><span style="color:#75715e"></span>	Person p4 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// Person p4 = Person(10); 
</span><span style="color:#75715e"></span>	Person p5 <span style="color:#f92672">=</span> p4; <span style="color:#75715e">// Person p5 = Person(p4); 
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//Person p5(p4);
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();
	<span style="color:#75715e">//test02();
</span><span style="color:#75715e"></span>
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.2.3</span> <span style="color:#960050;background-color:#1e0010">拷贝构造函数调用时机</span>
C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">中拷贝构造函数调用时机通常有三种情况</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">使用一个已经创建完毕的对象来初始化一个新对象</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">值传递的方式给函数参数传值</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">以值方式返回局部对象</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Person() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;无参构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
		mAge <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	}
	Person(<span style="color:#66d9ef">int</span> age) {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;有参构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
		mAge <span style="color:#f92672">=</span> age;
	}
	Person(<span style="color:#66d9ef">const</span> Person<span style="color:#f92672">&amp;</span> p) {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;拷贝构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
		mAge <span style="color:#f92672">=</span> p.mAge;
	}
	<span style="color:#75715e">//析构函数在释放内存之前调用
</span><span style="color:#75715e"></span>	<span style="color:#f92672">~</span>Person() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;析构函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> mAge;
};

<span style="color:#75715e">//1. 使用一个已经创建完毕的对象来初始化一个新对象
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>() {

	Person man(<span style="color:#ae81ff">100</span>); <span style="color:#75715e">//p对象已经创建完毕
</span><span style="color:#75715e"></span>	Person newman(man); <span style="color:#75715e">//调用拷贝构造函数
</span><span style="color:#75715e"></span>	Person newman2 <span style="color:#f92672">=</span> man; <span style="color:#75715e">//拷贝构造
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//Person newman3;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//newman3 = man; //不是调用拷贝构造函数，赋值操作
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">//2. 值传递的方式给函数参数传值
</span><span style="color:#75715e">//相当于Person p1 = p;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doWork</span>(Person p1) {}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test02</span>() {
	Person p; <span style="color:#75715e">//无参构造函数
</span><span style="color:#75715e"></span>	doWork(p);
}

<span style="color:#75715e">//3. 以值方式返回局部对象
</span><span style="color:#75715e"></span>Person <span style="color:#a6e22e">doWork2</span>()
{
	Person p1;
	cout <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>p1 <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">return</span> p1;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test03</span>()
{
	Person p <span style="color:#f92672">=</span> doWork2();
	cout <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>p <span style="color:#f92672">&lt;&lt;</span> endl;
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#75715e">//test01();
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//test02();
</span><span style="color:#75715e"></span>	test03();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.2.4</span> <span style="color:#960050;background-color:#1e0010">构造函数调用规则</span>
<span style="color:#960050;background-color:#1e0010">默认情况下，</span>c<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">编译器至少给一个类添加</span><span style="color:#ae81ff">3</span><span style="color:#960050;background-color:#1e0010">个函数</span>

<span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">．默认构造函数</span>(<span style="color:#960050;background-color:#1e0010">无参，函数体为空</span>)

<span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">．默认析构函数</span>(<span style="color:#960050;background-color:#1e0010">无参，函数体为空</span>)

<span style="color:#ae81ff">3</span><span style="color:#960050;background-color:#1e0010">．默认拷贝构造函数，对属性进行值拷贝</span>

<span style="color:#960050;background-color:#1e0010">构造函数调用规则如下：</span>
<span style="color:#f92672">*</span> 
<span style="color:#960050;background-color:#1e0010">如果用户定义有参构造函数，</span>c<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">不在提供默认无参构造，但是会提供默认拷贝构造</span>

<span style="color:#f92672">*</span> 
<span style="color:#960050;background-color:#1e0010">如果用户定义拷贝构造函数，</span>c<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">不会再提供其他构造函数</span>


<span style="color:#960050;background-color:#1e0010">示例：</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#75715e">//无参（默认）构造函数
</span><span style="color:#75715e"></span>	Person() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;无参构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//有参构造函数
</span><span style="color:#75715e"></span>	Person(<span style="color:#66d9ef">int</span> a) {
		age <span style="color:#f92672">=</span> a;
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;有参构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//拷贝构造函数
</span><span style="color:#75715e"></span>	Person(<span style="color:#66d9ef">const</span> Person<span style="color:#f92672">&amp;</span> p) {
		age <span style="color:#f92672">=</span> p.age;
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;拷贝构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//析构函数
</span><span style="color:#75715e"></span>	<span style="color:#f92672">~</span>Person() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;析构函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> age;
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	Person p1(<span style="color:#ae81ff">18</span>);
	<span style="color:#75715e">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作
</span><span style="color:#75715e"></span>	Person p2(p1);

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p2的年龄为： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p2.age <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test02</span>()
{
	<span style="color:#75715e">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
</span><span style="color:#75715e"></span>	Person p1; <span style="color:#75715e">//此时如果用户自己没有提供默认构造，会出错
</span><span style="color:#75715e"></span>	Person p2(<span style="color:#ae81ff">10</span>); <span style="color:#75715e">//用户提供的有参
</span><span style="color:#75715e"></span>	Person p3(p2); <span style="color:#75715e">//此时如果用户没有提供拷贝构造，编译器会提供
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//如果用户提供拷贝构造，编译器不会提供其他构造函数
</span><span style="color:#75715e"></span>	Person p4; <span style="color:#75715e">//此时如果用户自己没有提供默认构造，会出错
</span><span style="color:#75715e"></span>	Person p5(<span style="color:#ae81ff">10</span>); <span style="color:#75715e">//此时如果用户自己没有提供有参，会出错
</span><span style="color:#75715e"></span>	Person p6(p5); <span style="color:#75715e">//用户自己提供拷贝构造
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.2.5</span> <span style="color:#960050;background-color:#1e0010">深拷贝与浅拷贝</span>
<span style="color:#960050;background-color:#1e0010">深浅拷贝是面试经典问题，也是常见的一个坑</span>

<span style="color:#960050;background-color:#1e0010">浅拷贝：简单的赋值拷贝操作</span>

<span style="color:#960050;background-color:#1e0010">深拷贝：在堆区重新申请空间，进行拷贝操作</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#75715e">//无参（默认）构造函数
</span><span style="color:#75715e"></span>	Person() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;无参构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//有参构造函数
</span><span style="color:#75715e"></span>	Person(<span style="color:#66d9ef">int</span> age ,<span style="color:#66d9ef">int</span> height) {
		
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;有参构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;

		m_age <span style="color:#f92672">=</span> age;
		m_height <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(height);
		
	}
	<span style="color:#75715e">//拷贝构造函数  
</span><span style="color:#75715e"></span>	Person(<span style="color:#66d9ef">const</span> Person<span style="color:#f92672">&amp;</span> p) {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;拷贝构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
		<span style="color:#75715e">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
</span><span style="color:#75715e"></span>		m_age <span style="color:#f92672">=</span> p.m_age;
		m_height <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#f92672">*</span>p.m_height);
		
	}

	<span style="color:#75715e">//析构函数
</span><span style="color:#75715e"></span>	<span style="color:#f92672">~</span>Person() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;析构函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
		<span style="color:#66d9ef">if</span> (m_height <span style="color:#f92672">!=</span> NULL)
		{
			<span style="color:#66d9ef">delete</span> m_height;
		}
	}
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_age;
	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> m_height;
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	Person p1(<span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">180</span>);

	Person p2(p1);

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p1的年龄： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p1.m_age <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; 身高： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>p1.m_height <span style="color:#f92672">&lt;&lt;</span> endl;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p2的年龄： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p2.m_age <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; 身高： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>p2.m_height <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```</span><span style="color:#f92672">&gt;</span> <span style="color:#960050;background-color:#1e0010">总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题####</span> <span style="color:#ae81ff">4.2.6</span> <span style="color:#960050;background-color:#1e0010">初始化列表</span>
<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">作用：</span><span style="color:#f92672">*</span>

C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">提供了初始化列表语法，用来初始化属性</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">语法：</span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">`构造函数</span>()<span style="color:#960050;background-color:#1e0010">：属性</span><span style="color:#ae81ff">1</span>(<span style="color:#960050;background-color:#1e0010">值</span><span style="color:#ae81ff">1</span>),<span style="color:#960050;background-color:#1e0010">属性</span><span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">（值</span><span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">）</span>... {}<span style="color:#960050;background-color:#1e0010">`</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	<span style="color:#75715e">////传统方式初始化
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//Person(int a, int b, int c) {
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//	m_A = a;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//	m_B = b;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//	m_C = c;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//}
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//初始化列表方式初始化
</span><span style="color:#75715e"></span>	Person(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> c) <span style="color:#f92672">:</span>m_A(a), m_B(b), m_C(c) {}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintPerson</span>() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mA:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_A <span style="color:#f92672">&lt;&lt;</span> endl;
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mB:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_B <span style="color:#f92672">&lt;&lt;</span> endl;
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mC:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_C <span style="color:#f92672">&lt;&lt;</span> endl;
	}
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_A;
	<span style="color:#66d9ef">int</span> m_B;
	<span style="color:#66d9ef">int</span> m_C;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	Person p(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);
	p.PrintPerson();


	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.2.7</span> <span style="color:#960050;background-color:#1e0010">类对象作为类成员</span>
C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">类中的成员可以是另一个类的对象，我们称该成员为</span> <span style="color:#960050;background-color:#1e0010">对象成员</span>

<span style="color:#960050;background-color:#1e0010">例如：</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {}
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>
{
    A a<span style="color:#960050;background-color:#1e0010">；</span>
}
</code></pre></div><p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Phone</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Phone(string name)
	{
		m_PhoneName <span style="color:#f92672">=</span> name;
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Phone构造&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

	<span style="color:#f92672">~</span>Phone()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Phone析构&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

	string m_PhoneName;

};


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	<span style="color:#75715e">//初始化列表可以告诉编译器调用哪一个构造函数
</span><span style="color:#75715e"></span>	Person(string name, string pName) <span style="color:#f92672">:</span>m_Name(name), m_Phone(pName)
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Person构造&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

	<span style="color:#f92672">~</span>Person()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Person析构&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">playGame</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> m_Name <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; 使用&#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_Phone.m_PhoneName <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; 牌手机! &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

	string m_Name;
	Phone m_Phone;

};
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	<span style="color:#75715e">//当类中成员是其他类对象时，我们称该成员为 对象成员
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//析构顺序与构造相反
</span><span style="color:#75715e"></span>	Person p(<span style="color:#e6db74">&#34;张三&#34;</span> , <span style="color:#e6db74">&#34;苹果X&#34;</span>);
	p.playGame();

}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.2.8</span> <span style="color:#960050;background-color:#1e0010">静态成员</span>
<span style="color:#960050;background-color:#1e0010">静态成员就是在成员变量和成员函数前加上关键字</span><span style="color:#66d9ef">static</span><span style="color:#960050;background-color:#1e0010">，称为静态成员</span>

<span style="color:#960050;background-color:#1e0010">静态成员分为：</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">静态成员变量</span>
	<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">所有对象共享同一份数据</span>
	<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">在编译阶段分配内存</span>
	<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">类内声明，类外初始化</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">静态成员函数</span>
	<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">所有对象共享同一个函数</span>
	<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">静态成员函数只能访问静态成员变量</span>

<span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">示例</span><span style="color:#ae81ff">1</span> <span style="color:#960050;background-color:#1e0010">：</span><span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">静态成员变量</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>
{
	
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> m_A; <span style="color:#75715e">//静态成员变量
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//静态成员变量特点：
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//1 在编译阶段分配内存
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//2 类内声明，类外初始化
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//3 所有对象共享同一份数据
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> m_B; <span style="color:#75715e">//静态成员变量也是有访问权限的
</span><span style="color:#75715e"></span>};
<span style="color:#66d9ef">int</span> Person<span style="color:#f92672">::</span>m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
<span style="color:#66d9ef">int</span> Person<span style="color:#f92672">::</span>m_B <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	<span style="color:#75715e">//静态成员变量两种访问方式
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//1、通过对象
</span><span style="color:#75715e"></span>	Person p1;
	p1.m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p1.m_A = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p1.m_A <span style="color:#f92672">&lt;&lt;</span> endl;

	Person p2;
	p2.m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p1.m_A = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p1.m_A <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">//共享同一份数据
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p2.m_A = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p2.m_A <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//2、通过类名
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;m_A = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> Person<span style="color:#f92672">::</span>m_A <span style="color:#f92672">&lt;&lt;</span> endl;


	<span style="color:#75715e">//cout &lt;&lt; &#34;m_B = &#34; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>**示例2：**静态成员函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>
{

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	<span style="color:#75715e">//静态成员函数特点：
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//1 程序共享一个函数
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//2 静态成员函数只能访问静态成员变量
</span><span style="color:#75715e"></span>	
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> func()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;func调用&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
		m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
		<span style="color:#75715e">//m_B = 100; //错误，不可以访问非静态成员变量
</span><span style="color:#75715e"></span>	}

	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> m_A; <span style="color:#75715e">//静态成员变量
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> m_B; <span style="color:#75715e">// 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>

	<span style="color:#75715e">//静态成员函数也是有访问权限的
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> func2()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;func2调用&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};
<span style="color:#66d9ef">int</span> Person<span style="color:#f92672">::</span>m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	<span style="color:#75715e">//静态成员变量两种访问方式
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//1、通过对象
</span><span style="color:#75715e"></span>	Person p1;
	p1.func();

	<span style="color:#75715e">//2、通过类名
</span><span style="color:#75715e"></span>	Person<span style="color:#f92672">::</span>func();


	<span style="color:#75715e">//Person::func2(); //私有权限访问不到
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```###</span> <span style="color:#ae81ff">4.3</span> C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">对象模型和</span>this指针
<span style="color:#75715e">#### 4.3.1 成员变量和成员函数分开存储
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">在</span>C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">中，类内的成员变量和成员函数分开存储</span>

<span style="color:#960050;background-color:#1e0010">只有非静态成员变量才属于类的对象上</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Person() {
		mA <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	}
	<span style="color:#75715e">//非静态成员变量占对象空间
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> mA;
	<span style="color:#75715e">//静态成员变量不占对象空间
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> mB; 
	<span style="color:#75715e">//函数也不占对象空间，所有函数共享一个函数实例
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mA:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>mA <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//静态成员函数也不占对象空间
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sfunc</span>() {
	}
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(Person) <span style="color:#f92672">&lt;&lt;</span> endl;

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.3.2</span> this指针概念
<span style="color:#960050;background-color:#1e0010">通过</span><span style="color:#ae81ff">4.3.1</span><span style="color:#960050;background-color:#1e0010">我们知道在</span>C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">中成员变量和成员函数是分开存储的</span>

<span style="color:#960050;background-color:#1e0010">每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</span>

<span style="color:#960050;background-color:#1e0010">那么问题是：这一块代码是如何区分那个对象调用自己的呢？</span>

c<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">通过提供特殊的对象指针，</span>this指针<span style="color:#960050;background-color:#1e0010">，解决上述问题。</span><span style="color:#f92672">*</span>this指针指向被调用的成员函数所属的对象<span style="color:#f92672">*</span>

this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义<span style="color:#960050;background-color:#1e0010">，直接使用即可</span>

this指针的用途<span style="color:#960050;background-color:#1e0010">：</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">当形参和成员变量同名时，可用</span>this指针来区分
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">在类的非静态成员函数中返回对象本身，可使用</span><span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	Person(<span style="color:#66d9ef">int</span> age)
	{
		<span style="color:#75715e">//1、当形参和成员变量同名时，可用this指针来区分
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>age <span style="color:#f92672">=</span> age;
	}

	Person<span style="color:#f92672">&amp;</span> PersonAddPerson(Person p)
	{
		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>age <span style="color:#f92672">+=</span> p.age;
		<span style="color:#75715e">//返回对象本身
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
	}

	<span style="color:#66d9ef">int</span> age;
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	Person p1(<span style="color:#ae81ff">10</span>);
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p1.age = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p1.age <span style="color:#f92672">&lt;&lt;</span> endl;

	Person p2(<span style="color:#ae81ff">10</span>);
	p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p2.age = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p2.age <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.3.3</span> <span style="color:#960050;background-color:#1e0010">空指针访问成员函数</span>
C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">中空指针也是可以调用成员函数的，但是也要注意有没有用到</span>this指针

<span style="color:#960050;background-color:#1e0010">如果用到</span>this指针<span style="color:#960050;background-color:#1e0010">，需要加以判断保证代码的健壮性</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#75715e">//空指针访问成员函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	<span style="color:#66d9ef">void</span> ShowClassName() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;我是Person类!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ShowPerson</span>() {
		<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> NULL) {
			<span style="color:#66d9ef">return</span>;
		}
		cout <span style="color:#f92672">&lt;&lt;</span> mAge <span style="color:#f92672">&lt;&lt;</span> endl;
	}

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> mAge;
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	Person <span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> NULL;
	p<span style="color:#f92672">-&gt;</span>ShowClassName(); <span style="color:#75715e">//空指针，可以调用成员函数
</span><span style="color:#75715e"></span>	p<span style="color:#f92672">-&gt;</span>ShowPerson();  <span style="color:#75715e">//但是如果成员函数中用到了this指针，就不可以了
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.3.4</span> const修饰成员函数
<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">常函数：</span><span style="color:#f92672">*</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">成员函数后加</span>const后我们称为这个函数为<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">常函数</span><span style="color:#f92672">*</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">常函数内不可以修改成员属性</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">成员属性声明时加关键字</span>mutable后<span style="color:#960050;background-color:#1e0010">，在常函数中依然可以修改</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">常对象：</span><span style="color:#f92672">*</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">声明对象前加</span>const称该对象为常对象
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">常对象只能调用常函数</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Person() {
		m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
		m_B <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	}

	<span style="color:#75715e">//this指针的本质是一个指针常量，指针的指向不可修改
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//如果想让指针指向的值也不可以修改，需要声明常函数
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ShowPerson</span>() <span style="color:#66d9ef">const</span> {
		<span style="color:#75715e">//const Type* const pointer;
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//this = NULL; //不能修改指针的指向 Person* const this;
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的
</span><span style="color:#75715e"></span>
		<span style="color:#75715e">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_B <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
	}

	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MyFunc</span>() <span style="color:#66d9ef">const</span> {
		<span style="color:#75715e">//mA = 10000;
</span><span style="color:#75715e"></span>	}

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_A;
	<span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">int</span> m_B; <span style="color:#75715e">//可修改 可变的
</span><span style="color:#75715e"></span>};


<span style="color:#75715e">//const修饰对象  常对象
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>() {

	<span style="color:#66d9ef">const</span> Person person; <span style="color:#75715e">//常量对象  
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> person.m_A <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#75715e">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问
</span><span style="color:#75715e"></span>	person.m_B <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>; <span style="color:#75715e">//但是常对象可以修改mutable修饰成员变量
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//常对象访问成员函数
</span><span style="color:#75715e"></span>	person.MyFunc(); <span style="color:#75715e">//常对象不能调用const的函数
</span><span style="color:#75715e"></span>
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```###</span> <span style="color:#ae81ff">4.4</span> <span style="color:#960050;background-color:#1e0010">友元</span>
<span style="color:#960050;background-color:#1e0010">生活中你的家有客厅</span>(Public)<span style="color:#960050;background-color:#1e0010">，有你的卧室</span>(Private)

<span style="color:#960050;background-color:#1e0010">客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</span>

<span style="color:#960050;background-color:#1e0010">但是呢，你也可以允许你的好闺蜜好基友进去。</span>

<span style="color:#960050;background-color:#1e0010">在程序里，有些私有属性</span> <span style="color:#960050;background-color:#1e0010">也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</span>

<span style="color:#960050;background-color:#1e0010">友元的目的就是让一个函数或者类</span> <span style="color:#960050;background-color:#1e0010">访问另一个类中私有成员</span>

<span style="color:#960050;background-color:#1e0010">友元的关键字为</span>  <span style="color:#f92672">==</span><span style="color:#66d9ef">friend</span><span style="color:#f92672">==</span>

<span style="color:#960050;background-color:#1e0010">友元的三种实现</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">全局函数做友元</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">类做友元</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">成员函数做友元</span>
<span style="color:#75715e">#### 4.4.1 全局函数做友元
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Building</span>
{
	<span style="color:#75715e">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">goodGay</span>(Building <span style="color:#f92672">*</span> building);

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	Building()
	{
		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_SittingRoom <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;客厅&#34;</span>;
		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_BedRoom <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;卧室&#34;</span>;
	}


<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	string m_SittingRoom; <span style="color:#75715e">//客厅
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	string m_BedRoom; <span style="color:#75715e">//卧室
</span><span style="color:#75715e"></span>};


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">goodGay</span>(Building <span style="color:#f92672">*</span> building)
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;好基友正在访问： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> building<span style="color:#f92672">-&gt;</span>m_SittingRoom <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;好基友正在访问： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> building<span style="color:#f92672">-&gt;</span>m_BedRoom <span style="color:#f92672">&lt;&lt;</span> endl;
}


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	Building b;
	goodGay(<span style="color:#f92672">&amp;</span>b);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.4.2</span> <span style="color:#960050;background-color:#1e0010">类做友元</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Building</span>;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">goodGay</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	goodGay();
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visit</span>();

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	Building <span style="color:#f92672">*</span>building;
};


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Building</span>
{
	<span style="color:#75715e">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">goodGay</span>;

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Building();

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	string m_SittingRoom; <span style="color:#75715e">//客厅
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	string m_BedRoom;<span style="color:#75715e">//卧室
</span><span style="color:#75715e"></span>};

Building<span style="color:#f92672">::</span>Building()
{
	<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_SittingRoom <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;客厅&#34;</span>;
	<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_BedRoom <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;卧室&#34;</span>;
}

goodGay<span style="color:#f92672">::</span>goodGay()
{
	building <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Building;
}

<span style="color:#66d9ef">void</span> goodGay<span style="color:#f92672">::</span>visit()
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;好基友正在访问&#34;</span> <span style="color:#f92672">&lt;&lt;</span> building<span style="color:#f92672">-&gt;</span>m_SittingRoom <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;好基友正在访问&#34;</span> <span style="color:#f92672">&lt;&lt;</span> building<span style="color:#f92672">-&gt;</span>m_BedRoom <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	goodGay gg;
	gg.visit();

}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.4.3</span> <span style="color:#960050;background-color:#1e0010">成员函数做友元</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Building</span>;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">goodGay</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	goodGay();
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visit</span>(); <span style="color:#75715e">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visit2</span>(); 

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	Building <span style="color:#f92672">*</span>building;
};


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Building</span>
{
	<span style="color:#75715e">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">void</span> goodGay<span style="color:#f92672">::</span>visit();

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Building();

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	string m_SittingRoom; <span style="color:#75715e">//客厅
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	string m_BedRoom;<span style="color:#75715e">//卧室
</span><span style="color:#75715e"></span>};

Building<span style="color:#f92672">::</span>Building()
{
	<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_SittingRoom <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;客厅&#34;</span>;
	<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_BedRoom <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;卧室&#34;</span>;
}

goodGay<span style="color:#f92672">::</span>goodGay()
{
	building <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Building;
}

<span style="color:#66d9ef">void</span> goodGay<span style="color:#f92672">::</span>visit()
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;好基友正在访问&#34;</span> <span style="color:#f92672">&lt;&lt;</span> building<span style="color:#f92672">-&gt;</span>m_SittingRoom <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;好基友正在访问&#34;</span> <span style="color:#f92672">&lt;&lt;</span> building<span style="color:#f92672">-&gt;</span>m_BedRoom <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">void</span> goodGay<span style="color:#f92672">::</span>visit2()
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;好基友正在访问&#34;</span> <span style="color:#f92672">&lt;&lt;</span> building<span style="color:#f92672">-&gt;</span>m_SittingRoom <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#75715e">//cout &lt;&lt; &#34;好基友正在访问&#34; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	goodGay  gg;
	gg.visit();

}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    
	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```###</span> <span style="color:#ae81ff">4.5</span> <span style="color:#960050;background-color:#1e0010">运算符重载</span>
<span style="color:#960050;background-color:#1e0010">运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</span>
<span style="color:#75715e">#### 4.5.1 加号运算符重载
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">作用：实现两个自定义数据类型相加的运算</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Person() {};
	Person(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
	{
		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_A <span style="color:#f92672">=</span> a;
		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_B <span style="color:#f92672">=</span> b;
	}
	<span style="color:#75715e">//成员函数实现 + 号运算符重载
</span><span style="color:#75715e"></span>	Person <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">const</span> Person<span style="color:#f92672">&amp;</span> p) {
		Person temp;
		temp.m_A <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_A <span style="color:#f92672">+</span> p.m_A;
		temp.m_B <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_B <span style="color:#f92672">+</span> p.m_B;
		<span style="color:#66d9ef">return</span> temp;
	}


<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_A;
	<span style="color:#66d9ef">int</span> m_B;
};

<span style="color:#75715e">//全局函数实现 + 号运算符重载
</span><span style="color:#75715e">//Person operator+(const Person&amp; p1, const Person&amp; p2) {
</span><span style="color:#75715e">//	Person temp(0, 0);
</span><span style="color:#75715e">//	temp.m_A = p1.m_A + p2.m_A;
</span><span style="color:#75715e">//	temp.m_B = p1.m_B + p2.m_B;
</span><span style="color:#75715e">//	return temp;
</span><span style="color:#75715e">//}
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//运算符重载 可以发生函数重载 
</span><span style="color:#75715e"></span>Person <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">const</span> Person<span style="color:#f92672">&amp;</span> p2, <span style="color:#66d9ef">int</span> val)  
{
	Person temp;
	temp.m_A <span style="color:#f92672">=</span> p2.m_A <span style="color:#f92672">+</span> val;
	temp.m_B <span style="color:#f92672">=</span> p2.m_B <span style="color:#f92672">+</span> val;
	<span style="color:#66d9ef">return</span> temp;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>() {

	Person p1(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>);
	Person p2(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">20</span>);

	<span style="color:#75715e">//成员函数方式
</span><span style="color:#75715e"></span>	Person p3 <span style="color:#f92672">=</span> p2 <span style="color:#f92672">+</span> p1;  <span style="color:#75715e">//相当于 p2.operaor+(p1)
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mA:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> p3.m_A <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; mB:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> p3.m_B <span style="color:#f92672">&lt;&lt;</span> endl;


	Person p4 <span style="color:#f92672">=</span> p3 <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">//相当于 operator+(p3,10)
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mA:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> p4.m_A <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; mB:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> p4.m_B <span style="color:#f92672">&lt;&lt;</span> endl;

}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```</span><span style="color:#f92672">&gt;</span> <span style="color:#960050;background-color:#1e0010">总结</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">：对于内置的数据类型的表达式的的运算符是不可能改变的</span><span style="color:#f92672">&gt;</span> <span style="color:#960050;background-color:#1e0010">总结</span><span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">：不要滥用运算符重载####</span> <span style="color:#ae81ff">4.5.2</span> <span style="color:#960050;background-color:#1e0010">左移运算符重载</span>
<span style="color:#960050;background-color:#1e0010">作用：可以输出自定义数据类型</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
	<span style="color:#66d9ef">friend</span> ostream<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(ostream<span style="color:#f92672">&amp;</span> out, Person<span style="color:#f92672">&amp;</span> p);

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	Person(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
	{
		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_A <span style="color:#f92672">=</span> a;
		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_B <span style="color:#f92672">=</span> b;
	}

	<span style="color:#75715e">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//void operator&lt;&lt;(Person&amp; p){
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//}
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_A;
	<span style="color:#66d9ef">int</span> m_B;
};

<span style="color:#75715e">//全局函数实现左移重载
</span><span style="color:#75715e">//ostream对象只能有一个
</span><span style="color:#75715e"></span>ostream<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(ostream<span style="color:#f92672">&amp;</span> out, Person<span style="color:#f92672">&amp;</span> p) {
	out <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.m_A <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; b:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.m_B;
	<span style="color:#66d9ef">return</span> out;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>() {

	Person p1(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>);

	cout <span style="color:#f92672">&lt;&lt;</span> p1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;hello world&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">//链式编程
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```</span><span style="color:#f92672">&gt;</span> <span style="color:#960050;background-color:#1e0010">总结：重载左移运算符配合友元可以实现输出自定义数据类型####</span> <span style="color:#ae81ff">4.5.3</span> <span style="color:#960050;background-color:#1e0010">递增运算符重载</span>
<span style="color:#960050;background-color:#1e0010">作用：</span> <span style="color:#960050;background-color:#1e0010">通过重载递增运算符，实现自己的整型数据</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyInteger</span> {

	<span style="color:#66d9ef">friend</span> ostream<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(ostream<span style="color:#f92672">&amp;</span> out, MyInteger myint);

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	MyInteger() {
		m_Num <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	}
	<span style="color:#75715e">//前置++
</span><span style="color:#75715e"></span>	MyInteger<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>() {
		<span style="color:#75715e">//先++
</span><span style="color:#75715e"></span>		m_Num<span style="color:#f92672">++</span>;
		<span style="color:#75715e">//再返回
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
	}

	<span style="color:#75715e">//后置++
</span><span style="color:#75715e"></span>	MyInteger <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">int</span>) {
		<span style="color:#75715e">//先返回
</span><span style="color:#75715e"></span>		MyInteger temp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>; <span style="color:#75715e">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；
</span><span style="color:#75715e"></span>		m_Num<span style="color:#f92672">++</span>;
		<span style="color:#66d9ef">return</span> temp;
	}

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_Num;
};


ostream<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(ostream<span style="color:#f92672">&amp;</span> out, MyInteger myint) {
	out <span style="color:#f92672">&lt;&lt;</span> myint.m_Num;
	<span style="color:#66d9ef">return</span> out;
}


<span style="color:#75715e">//前置++ 先++ 再返回
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>() {
	MyInteger myInt;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">++</span>myInt <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> myInt <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#75715e">//后置++ 先返回 再++
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test02</span>() {

	MyInteger myInt;
	cout <span style="color:#f92672">&lt;&lt;</span> myInt<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> myInt <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();
	<span style="color:#75715e">//test02();
</span><span style="color:#75715e"></span>
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```</span><span style="color:#f92672">&gt;</span> <span style="color:#960050;background-color:#1e0010">总结：</span> <span style="color:#960050;background-color:#1e0010">前置递增返回引用，后置递增返回值####</span> <span style="color:#ae81ff">4.5.4</span> <span style="color:#960050;background-color:#1e0010">赋值运算符重载</span>
c<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">编译器至少给一个类添加</span><span style="color:#ae81ff">4</span><span style="color:#960050;background-color:#1e0010">个函数</span>
<span style="color:#ae81ff">1.</span> <span style="color:#960050;background-color:#1e0010">默认构造函数</span>(<span style="color:#960050;background-color:#1e0010">无参，函数体为空</span>)
<span style="color:#ae81ff">2.</span> <span style="color:#960050;background-color:#1e0010">默认析构函数</span>(<span style="color:#960050;background-color:#1e0010">无参，函数体为空</span>)
<span style="color:#ae81ff">3.</span> <span style="color:#960050;background-color:#1e0010">默认拷贝构造函数，对属性进行值拷贝</span>
<span style="color:#ae81ff">4.</span> <span style="color:#960050;background-color:#1e0010">赋值运算符</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>, <span style="color:#960050;background-color:#1e0010">对属性进行值拷贝</span>

<span style="color:#960050;background-color:#1e0010">如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	Person(<span style="color:#66d9ef">int</span> age)
	{
		<span style="color:#75715e">//将年龄数据开辟到堆区
</span><span style="color:#75715e"></span>		m_Age <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(age);
	}

	<span style="color:#75715e">//重载赋值运算符 
</span><span style="color:#75715e"></span>	Person<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(Person <span style="color:#f92672">&amp;</span>p)
	{
		<span style="color:#66d9ef">if</span> (m_Age <span style="color:#f92672">!=</span> NULL)
		{
			<span style="color:#66d9ef">delete</span> m_Age;
			m_Age <span style="color:#f92672">=</span> NULL;
		}
		<span style="color:#75715e">//编译器提供的代码是浅拷贝
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//m_Age = p.m_Age;
</span><span style="color:#75715e"></span>
		<span style="color:#75715e">//提供深拷贝 解决浅拷贝的问题
</span><span style="color:#75715e"></span>		m_Age <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#f92672">*</span>p.m_Age);

		<span style="color:#75715e">//返回自身
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
	}


	<span style="color:#f92672">~</span>Person()
	{
		<span style="color:#66d9ef">if</span> (m_Age <span style="color:#f92672">!=</span> NULL)
		{
			<span style="color:#66d9ef">delete</span> m_Age;
			m_Age <span style="color:#f92672">=</span> NULL;
		}
	}

	<span style="color:#75715e">//年龄的指针
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>m_Age;

};


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	Person p1(<span style="color:#ae81ff">18</span>);

	Person p2(<span style="color:#ae81ff">20</span>);

	Person p3(<span style="color:#ae81ff">30</span>);

	p3 <span style="color:#f92672">=</span> p2 <span style="color:#f92672">=</span> p1; <span style="color:#75715e">//赋值操作
</span><span style="color:#75715e"></span>
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p1的年龄为：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>p1.m_Age <span style="color:#f92672">&lt;&lt;</span> endl;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p2的年龄为：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>p2.m_Age <span style="color:#f92672">&lt;&lt;</span> endl;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;p3的年龄为：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>p3.m_Age <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	<span style="color:#75715e">//int a = 10;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//int b = 20;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//int c = 30;
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//c = b = a;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//cout &lt;&lt; &#34;a = &#34; &lt;&lt; a &lt;&lt; endl;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//cout &lt;&lt; &#34;b = &#34; &lt;&lt; b &lt;&lt; endl;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//cout &lt;&lt; &#34;c = &#34; &lt;&lt; c &lt;&lt; endl;
</span><span style="color:#75715e"></span>
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.5.5</span> <span style="color:#960050;background-color:#1e0010">关系运算符重载</span>
<span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">作用：</span><span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">重载关系运算符，可以让两个自定义类型对象进行对比操作</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Person(string name, <span style="color:#66d9ef">int</span> age)
	{
		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_Name <span style="color:#f92672">=</span> name;
		<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_Age <span style="color:#f92672">=</span> age;
	};

	<span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(Person <span style="color:#f92672">&amp;</span> p)
	{
		<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_Name <span style="color:#f92672">==</span> p.m_Name <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_Age <span style="color:#f92672">==</span> p.m_Age)
		{
			<span style="color:#66d9ef">return</span> true;
		}
		<span style="color:#66d9ef">else</span>
		{
			<span style="color:#66d9ef">return</span> false;
		}
	}

	<span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">!=</span>(Person <span style="color:#f92672">&amp;</span> p)
	{
		<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_Name <span style="color:#f92672">==</span> p.m_Name <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_Age <span style="color:#f92672">==</span> p.m_Age)
		{
			<span style="color:#66d9ef">return</span> false;
		}
		<span style="color:#66d9ef">else</span>
		{
			<span style="color:#66d9ef">return</span> true;
		}
	}

	string m_Name;
	<span style="color:#66d9ef">int</span> m_Age;
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	<span style="color:#75715e">//int a = 0;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//int b = 0;
</span><span style="color:#75715e"></span>
	Person a(<span style="color:#e6db74">&#34;孙悟空&#34;</span>, <span style="color:#ae81ff">18</span>);
	Person b(<span style="color:#e6db74">&#34;孙悟空&#34;</span>, <span style="color:#ae81ff">18</span>);

	<span style="color:#66d9ef">if</span> (a <span style="color:#f92672">==</span> b)
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a和b相等&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">else</span>
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a和b不相等&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

	<span style="color:#66d9ef">if</span> (a <span style="color:#f92672">!=</span> b)
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a和b不相等&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">else</span>
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a和b相等&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.5.6</span> <span style="color:#960050;background-color:#1e0010">函数调用运算符重载</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">函数调用运算符</span> ()  <span style="color:#960050;background-color:#1e0010">也可以重载</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">由于重载后使用的方式非常像函数的调用，因此称为仿函数</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">仿函数没有固定写法，非常灵活</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyPrint</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span>()(string text)
	{
		cout <span style="color:#f92672">&lt;&lt;</span> text <span style="color:#f92672">&lt;&lt;</span> endl;
	}

};
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	<span style="color:#75715e">//重载的（）操作符 也称为仿函数
</span><span style="color:#75715e"></span>	MyPrint myFunc;
	myFunc(<span style="color:#e6db74">&#34;hello world&#34;</span>);
}


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyAdd</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">int</span> v1, <span style="color:#66d9ef">int</span> v2)
	{
		<span style="color:#66d9ef">return</span> v1 <span style="color:#f92672">+</span> v2;
	}
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test02</span>()
{
	MyAdd add;
	<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> add(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>);
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ret = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ret <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//匿名对象调用  
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;MyAdd()(100,100) = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> MyAdd()(<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">100</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();
	test02();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```###</span> <span style="color:#ae81ff">4.6</span>  <span style="color:#960050;background-color:#1e0010">继承</span>
<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">继承是面向对象三大特性之一</span><span style="color:#f92672">*</span>

<span style="color:#960050;background-color:#1e0010">有些类与类之间存在特殊的关系，例如下图中：</span>

<span style="color:#ae81ff">1544861202252</span>

<span style="color:#960050;background-color:#1e0010">我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</span>

<span style="color:#960050;background-color:#1e0010">这个时候我们就可以考虑利用继承的技术，减少重复代码</span>
<span style="color:#75715e">#### 4.6.1 继承的基本语法
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</span>

<span style="color:#960050;background-color:#1e0010">接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">普通实现：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#75715e">//Java页面
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Java</span> 
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> header()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;首页、公开课、登录、注册...（公共头部）&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">footer</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;帮助中心、交流合作、站内地图...(公共底部)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">left</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Java,Python,C++...(公共分类列表)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">content</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;JAVA学科视频&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};
<span style="color:#75715e">//Python页面
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Python</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> header()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;首页、公开课、登录、注册...（公共头部）&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">footer</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;帮助中心、交流合作、站内地图...(公共底部)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">left</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Java,Python,C++...(公共分类列表)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">content</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Python学科视频&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};
<span style="color:#75715e">//C++页面
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CPP</span> 
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> header()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;首页、公开课、登录、注册...（公共头部）&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">footer</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;帮助中心、交流合作、站内地图...(公共底部)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">left</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Java,Python,C++...(公共分类列表)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">content</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C++学科视频&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	<span style="color:#75715e">//Java页面
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Java下载视频页面如下： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	Java ja;
	ja.header();
	ja.footer();
	ja.left();
	ja.content();
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;--------------------&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//Python页面
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Python下载视频页面如下： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	Python py;
	py.header();
	py.footer();
	py.left();
	py.content();
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;--------------------&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//C++页面
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C++下载视频页面如下： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	CPP cp;
	cp.header();
	cp.footer();
	cp.left();
	cp.content();

}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><em>继承实现：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//公共页面
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BasePage</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> header()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;首页、公开课、登录、注册...（公共头部）&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">footer</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;帮助中心、交流合作、站内地图...(公共底部)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">left</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Java,Python,C++...(公共分类列表)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

};

<span style="color:#75715e">//Java页面
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Java</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> BasePage
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> content()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;JAVA学科视频&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};
<span style="color:#75715e">//Python页面
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Python</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> BasePage
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> content()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Python学科视频&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};
<span style="color:#75715e">//C++页面
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CPP</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> BasePage
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> content()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C++学科视频&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	<span style="color:#75715e">//Java页面
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Java下载视频页面如下： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	Java ja;
	ja.header();
	ja.footer();
	ja.left();
	ja.content();
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;--------------------&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//Python页面
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Python下载视频页面如下： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	Python py;
	py.header();
	py.footer();
	py.left();
	py.content();
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;--------------------&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//C++页面
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C++下载视频页面如下： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	CPP cp;
	cp.header();
	cp.footer();
	cp.left();
	cp.content();


}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><em>总结：</em></p>
<p>继承的好处：==可以减少重复的代码==</p>
<p>class A : public B;</p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><em>派生类中的成员，包含两大部分</em>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="462-继承方式">4.6.2 继承方式<a hidden class="anchor" aria-hidden="true" href="#462-继承方式">#</a></h4>
<p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><em>继承方式一共有三种：</em></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p>img</p>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base1</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span> 
	<span style="color:#66d9ef">int</span> m_A;
<span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_B;
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_C;
};

<span style="color:#75715e">//公共继承
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Son1</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Base1
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> func()
	{
		m_A; <span style="color:#75715e">//可访问 public权限
</span><span style="color:#75715e"></span>		m_B; <span style="color:#75715e">//可访问 protected权限
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//m_C; //不可访问
</span><span style="color:#75715e"></span>	}
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myClass</span>()
{
	Son1 s1;
	s1.m_A; <span style="color:#75715e">//其他类只能访问到公共权限
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">//保护继承
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base2</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_A;
<span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_B;
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_C;
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Son2</span><span style="color:#f92672">:</span><span style="color:#66d9ef">protected</span> Base2
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> func()
	{
		m_A; <span style="color:#75715e">//可访问 protected权限
</span><span style="color:#75715e"></span>		m_B; <span style="color:#75715e">//可访问 protected权限
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//m_C; //不可访问
</span><span style="color:#75715e"></span>	}
};
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myClass2</span>()
{
	Son2 s;
	<span style="color:#75715e">//s.m_A; //不可访问
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">//私有继承
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base3</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_A;
<span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_B;
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_C;
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Son3</span><span style="color:#f92672">:</span><span style="color:#66d9ef">private</span> Base3
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> func()
	{
		m_A; <span style="color:#75715e">//可访问 private权限
</span><span style="color:#75715e"></span>		m_B; <span style="color:#75715e">//可访问 private权限
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//m_C; //不可访问
</span><span style="color:#75715e"></span>	}
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GrandSon3</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Son3
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> func()
	{
		<span style="color:#75715e">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//m_A;
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//m_B;
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//m_C;
</span><span style="color:#75715e"></span>	}
};
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.6.3</span> <span style="color:#960050;background-color:#1e0010">继承中的对象模型</span>
<span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">问题：</span><span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">从父类继承过来的成员，哪些属于子类对象中？</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_A;
<span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_B;
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_C; <span style="color:#75715e">//私有成员只是被隐藏了，但是还是会继承下去
</span><span style="color:#75715e"></span>};

<span style="color:#75715e">//公共继承
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Son</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Base
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_D;
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;sizeof Son = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(Son) <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>利用工具查看：</p>
<p>1545881904150</p>
<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p>
<p>效果如下图：</p>
<p>1545882158050</p>
<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到#### 4.6.4 继承中构造和析构顺序
子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
</blockquote>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> 
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Base()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#f92672">~</span>Base()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base析构函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Son</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Son()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Son构造函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#f92672">~</span>Son()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Son析构函数!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

};


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	<span style="color:#75715e">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反
</span><span style="color:#75715e"></span>	Son s;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```</span><span style="color:#f92672">&gt;</span> <span style="color:#960050;background-color:#1e0010">总结：继承中</span> <span style="color:#960050;background-color:#1e0010">先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反####</span> <span style="color:#ae81ff">4.6.5</span> <span style="color:#960050;background-color:#1e0010">继承同名成员处理方式</span>
<span style="color:#960050;background-color:#1e0010">问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">访问子类同名成员</span>   <span style="color:#960050;background-color:#1e0010">直接访问即可</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">访问父类同名成员</span>   <span style="color:#960050;background-color:#1e0010">需要加作用域</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Base()
	{
		m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
	}

	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base - func()调用&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(<span style="color:#66d9ef">int</span> a)
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base - func(int a)调用&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_A;
};


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Son</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Son()
	{
		m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>;
	}

	<span style="color:#75715e">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Son - func()调用&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_A;
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	Son s;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Son下的m_A = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s.m_A <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base下的m_A = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s.Base<span style="color:#f92672">::</span>m_A <span style="color:#f92672">&lt;&lt;</span> endl;

	s.func();
	s.Base<span style="color:#f92672">::</span>func();
	s.Base<span style="color:#f92672">::</span>func(<span style="color:#ae81ff">10</span>);

}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
}
</code></pre></div><p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="466-继承同名静态成员处理方式">4.6.6 继承同名静态成员处理方式<a hidden class="anchor" aria-hidden="true" href="#466-继承同名静态成员处理方式">#</a></h4>
<p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> func()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base - static void func()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(<span style="color:#66d9ef">int</span> a)
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base - static void func(int a)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> m_A;
};

<span style="color:#66d9ef">int</span> Base<span style="color:#f92672">::</span>m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Son</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> func()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Son - static void func()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> m_A;
};

<span style="color:#66d9ef">int</span> Son<span style="color:#f92672">::</span>m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>;

<span style="color:#75715e">//同名成员属性
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	<span style="color:#75715e">//通过对象访问
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;通过对象访问： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	Son s;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Son  下 m_A = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s.m_A <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base 下 m_A = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s.Base<span style="color:#f92672">::</span>m_A <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//通过类名访问
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;通过类名访问： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Son  下 m_A = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> Son<span style="color:#f92672">::</span>m_A <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base 下 m_A = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> Son<span style="color:#f92672">::</span>Base<span style="color:#f92672">::</span>m_A <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#75715e">//同名成员函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test02</span>()
{
	<span style="color:#75715e">//通过对象访问
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;通过对象访问： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	Son s;
	s.func();
	s.Base<span style="color:#f92672">::</span>func();

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;通过类名访问： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	Son<span style="color:#f92672">::</span>func();
	Son<span style="color:#f92672">::</span>Base<span style="color:#f92672">::</span>func();
	<span style="color:#75715e">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问
</span><span style="color:#75715e"></span>	Son<span style="color:#f92672">::</span>Base<span style="color:#f92672">::</span>func(<span style="color:#ae81ff">100</span>);
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#75715e">//test01();
</span><span style="color:#75715e"></span>	test02();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```</span><span style="color:#f92672">&gt;</span> <span style="color:#960050;background-color:#1e0010">总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象</span> <span style="color:#960050;background-color:#1e0010">和</span> <span style="color:#960050;background-color:#1e0010">通过类名）####</span> <span style="color:#ae81ff">4.6.7</span> <span style="color:#960050;background-color:#1e0010">多继承语法</span>
C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">允许</span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">一个类继承多个类</span><span style="color:#f92672">*</span>

<span style="color:#960050;background-color:#1e0010">语法：`</span> <span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">子类 ：继承方式 父类1 ， 继承方式 父类2...`</span>

<span style="color:#960050;background-color:#1e0010">多继承可能会引发父类中有同名成员出现，需要加作用域区分</span>

<span style="color:#f92672">*</span>C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">实际开发中不建议用多继承</span><span style="color:#f92672">*</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base1</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Base1()
	{
		m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
	}
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_A;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base2</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Base2()
	{
		m_A <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>;  <span style="color:#75715e">//开始是m_B 不会出问题，但是改为mA就会出现不明确
</span><span style="color:#75715e"></span>	}
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_A;
};

<span style="color:#75715e">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Son</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base2, <span style="color:#66d9ef">public</span> Base1 
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Son()
	{
		m_C <span style="color:#f92672">=</span> <span style="color:#ae81ff">300</span>;
		m_D <span style="color:#f92672">=</span> <span style="color:#ae81ff">400</span>;
	}
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_C;
	<span style="color:#66d9ef">int</span> m_D;
};


<span style="color:#75715e">//多继承容易产生成员同名的情况
</span><span style="color:#75715e">//通过使用类名作用域可以区分调用哪一个基类的成员
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	Son s;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;sizeof Son = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(s) <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> s.Base1<span style="color:#f92672">::</span>m_A <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> s.Base2<span style="color:#f92672">::</span>m_A <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```</span><span style="color:#f92672">&gt;</span> <span style="color:#960050;background-color:#1e0010">总结：</span> <span style="color:#960050;background-color:#1e0010">多继承中如果父类中出现了同名情况，子类使用时候要加作用域####</span> <span style="color:#ae81ff">4.6.8</span> <span style="color:#960050;background-color:#1e0010">菱形继承</span>
<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">菱形继承概念：</span><span style="color:#f92672">*</span>

	<span style="color:#960050;background-color:#1e0010">两个派生类继承同一个基类</span>

	<span style="color:#960050;background-color:#1e0010">又有某个类同时继承者两个派生类</span>

	<span style="color:#960050;background-color:#1e0010">这种继承被称为菱形继承，或者钻石继承</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">典型的菱形继承案例：</span><span style="color:#f92672">*</span>

IMG_256

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">菱形继承问题：</span><span style="color:#f92672">*</span>
<span style="color:#ae81ff">1.</span> <span style="color:#960050;background-color:#1e0010">```</span>
<span style="color:#960050;background-color:#1e0010">羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</span>
</code></pre></div><ol start="2">
<li></li>
</ol>
<p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Animal</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_Age;
};

<span style="color:#75715e">//继承前加virtual关键字后，变为虚继承
</span><span style="color:#75715e">//此时公共的父类Animal称为虚基类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Sheep</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> Animal {};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Tuo</span>   <span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> Animal {};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SheepTuo</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Sheep, <span style="color:#66d9ef">public</span> Tuo {};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	SheepTuo st;
	st.Sheep<span style="color:#f92672">::</span>m_Age <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
	st.Tuo<span style="color:#f92672">::</span>m_Age <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;st.Sheep::m_Age = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> st.Sheep<span style="color:#f92672">::</span>m_Age <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;st.Tuo::m_Age = &#34;</span> <span style="color:#f92672">&lt;&lt;</span>  st.Tuo<span style="color:#f92672">::</span>m_Age <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;st.m_Age = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> st.m_Age <span style="color:#f92672">&lt;&lt;</span> endl;
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<h3 id="47--多态">4.7  多态<a hidden class="anchor" aria-hidden="true" href="#47--多态">#</a></h3>
<h4 id="471-多态的基本概念">4.7.1 多态的基本概念<a hidden class="anchor" aria-hidden="true" href="#471-多态的基本概念">#</a></h4>
<p><em>多态是C++面向对象三大特性之一</em></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Animal</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#75715e">//Speak函数就是虚函数
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> speak()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;动物在说话&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Animal
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">void</span> speak()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;小猫在说话&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Animal
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	<span style="color:#66d9ef">void</span> speak()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;小狗在说话&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

};
<span style="color:#75715e">//我们希望传入什么对象，那么就调用什么对象的函数
</span><span style="color:#75715e">//如果函数地址在编译阶段就能确定，那么静态联编
</span><span style="color:#75715e">//如果函数地址在运行阶段才能确定，就是动态联编
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DoSpeak</span>(Animal <span style="color:#f92672">&amp;</span> animal)
{
	animal.speak();
}
<span style="color:#75715e">//
</span><span style="color:#75715e">//多态满足条件： 
</span><span style="color:#75715e">//1、有继承关系
</span><span style="color:#75715e">//2、子类重写父类中的虚函数
</span><span style="color:#75715e">//多态使用：
</span><span style="color:#75715e">//父类指针或引用指向子类对象
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	Cat cat;
	DoSpeak(cat);


	Dog dog;
	DoSpeak(dog);
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p>
<h4 id="472-多态案例一-计算器类">4.7.2 多态案例一-计算器类<a hidden class="anchor" aria-hidden="true" href="#472-多态案例一-计算器类">#</a></h4>
<p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//普通实现
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Calculator</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> getResult(string oper)
	{
		<span style="color:#66d9ef">if</span> (oper <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;+&#34;</span>) {
			<span style="color:#66d9ef">return</span> m_Num1 <span style="color:#f92672">+</span> m_Num2;
		}
		<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (oper <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;-&#34;</span>) {
			<span style="color:#66d9ef">return</span> m_Num1 <span style="color:#f92672">-</span> m_Num2;
		}
		<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (oper <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;*&#34;</span>) {
			<span style="color:#66d9ef">return</span> m_Num1 <span style="color:#f92672">*</span> m_Num2;
		}
		<span style="color:#75715e">//如果要提供新的运算，需要修改源码
</span><span style="color:#75715e"></span>	}
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> m_Num1;
	<span style="color:#66d9ef">int</span> m_Num2;
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	<span style="color:#75715e">//普通实现测试
</span><span style="color:#75715e"></span>	Calculator c;
	c.m_Num1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	c.m_Num2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> c.m_Num1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; + &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.m_Num2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.getResult(<span style="color:#e6db74">&#34;+&#34;</span>) <span style="color:#f92672">&lt;&lt;</span> endl;

	cout <span style="color:#f92672">&lt;&lt;</span> c.m_Num1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; - &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.m_Num2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.getResult(<span style="color:#e6db74">&#34;-&#34;</span>) <span style="color:#f92672">&lt;&lt;</span> endl;

	cout <span style="color:#f92672">&lt;&lt;</span> c.m_Num1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; * &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.m_Num2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.getResult(<span style="color:#e6db74">&#34;*&#34;</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
}



<span style="color:#75715e">//多态实现
</span><span style="color:#75715e">//抽象计算器类
</span><span style="color:#75715e">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractCalculator</span>
{
<span style="color:#66d9ef">public</span> <span style="color:#f92672">:</span>

	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">int</span> getResult()
	{
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
	}

	<span style="color:#66d9ef">int</span> m_Num1;
	<span style="color:#66d9ef">int</span> m_Num2;
};

<span style="color:#75715e">//加法计算器
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AddCalculator</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> AbstractCalculator
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> getResult()
	{
		<span style="color:#66d9ef">return</span> m_Num1 <span style="color:#f92672">+</span> m_Num2;
	}
};

<span style="color:#75715e">//减法计算器
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SubCalculator</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> AbstractCalculator
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> getResult()
	{
		<span style="color:#66d9ef">return</span> m_Num1 <span style="color:#f92672">-</span> m_Num2;
	}
};

<span style="color:#75715e">//乘法计算器
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MulCalculator</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> AbstractCalculator
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> getResult()
	{
		<span style="color:#66d9ef">return</span> m_Num1 <span style="color:#f92672">*</span> m_Num2;
	}
};


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test02</span>()
{
	<span style="color:#75715e">//创建加法计算器
</span><span style="color:#75715e"></span>	AbstractCalculator <span style="color:#f92672">*</span>abc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AddCalculator;
	abc<span style="color:#f92672">-&gt;</span>m_Num1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	abc<span style="color:#f92672">-&gt;</span>m_Num2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> abc<span style="color:#f92672">-&gt;</span>m_Num1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; + &#34;</span> <span style="color:#f92672">&lt;&lt;</span> abc<span style="color:#f92672">-&gt;</span>m_Num2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> abc<span style="color:#f92672">-&gt;</span>getResult() <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">delete</span> abc;  <span style="color:#75715e">//用完了记得销毁
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//创建减法计算器
</span><span style="color:#75715e"></span>	abc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SubCalculator;
	abc<span style="color:#f92672">-&gt;</span>m_Num1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	abc<span style="color:#f92672">-&gt;</span>m_Num2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> abc<span style="color:#f92672">-&gt;</span>m_Num1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; - &#34;</span> <span style="color:#f92672">&lt;&lt;</span> abc<span style="color:#f92672">-&gt;</span>m_Num2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> abc<span style="color:#f92672">-&gt;</span>getResult() <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">delete</span> abc;  

	<span style="color:#75715e">//创建乘法计算器
</span><span style="color:#75715e"></span>	abc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MulCalculator;
	abc<span style="color:#f92672">-&gt;</span>m_Num1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	abc<span style="color:#f92672">-&gt;</span>m_Num2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> abc<span style="color:#f92672">-&gt;</span>m_Num1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; * &#34;</span> <span style="color:#f92672">&lt;&lt;</span> abc<span style="color:#f92672">-&gt;</span>m_Num2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> abc<span style="color:#f92672">-&gt;</span>getResult() <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">delete</span> abc;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	<span style="color:#75715e">//test01();
</span><span style="color:#75715e"></span>
	test02();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```</span><span style="color:#f92672">&gt;</span> <span style="color:#960050;background-color:#1e0010">总结：</span>C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">开发提倡利用多态设计程序架构，因为多态优点很多####</span> <span style="color:#ae81ff">4.7.3</span> <span style="color:#960050;background-color:#1e0010">纯虚函数和抽象类</span>
<span style="color:#960050;background-color:#1e0010">在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</span>

<span style="color:#960050;background-color:#1e0010">因此可以将虚函数改为</span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">纯虚函数</span><span style="color:#f92672">*</span>

<span style="color:#960050;background-color:#1e0010">纯虚函数语法：`</span><span style="color:#66d9ef">virtual</span> <span style="color:#960050;background-color:#1e0010">返回值类型</span> <span style="color:#960050;background-color:#1e0010">函数名</span> <span style="color:#960050;background-color:#1e0010">（参数列表）</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ;<span style="color:#960050;background-color:#1e0010">`</span>

<span style="color:#960050;background-color:#1e0010">当类中有了纯虚函数，这个类也称为</span><span style="color:#f92672">==</span><span style="color:#960050;background-color:#1e0010">抽象类</span><span style="color:#f92672">==</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">抽象类特点</span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">：</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">无法实例化对象</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">子类必须重写抽象类中的纯虚函数，否则也属于抽象类</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#75715e">//纯虚函数
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//类中只要有一个纯虚函数就称为抽象类
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//抽象类无法实例化对象
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//子类必须重写父类中的纯虚函数，否则也属于抽象类
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> func() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Son</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Base
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> func() 
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;func调用&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	};
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	Base <span style="color:#f92672">*</span> base <span style="color:#f92672">=</span> NULL;
	<span style="color:#75715e">//base = new Base; // 错误，抽象类无法实例化对象
</span><span style="color:#75715e"></span>	base <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Son;
	base<span style="color:#f92672">-&gt;</span>func();
	<span style="color:#66d9ef">delete</span> base;<span style="color:#75715e">//记得销毁
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.7.4</span> <span style="color:#960050;background-color:#1e0010">多态案例二</span><span style="color:#f92672">-</span><span style="color:#960050;background-color:#1e0010">制作饮品</span>
<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">案例描述：</span><span style="color:#f92672">*</span>

<span style="color:#960050;background-color:#1e0010">制作饮品的大致流程为：煮水</span> <span style="color:#f92672">-</span>  <span style="color:#960050;background-color:#1e0010">冲泡</span> <span style="color:#f92672">-</span> <span style="color:#960050;background-color:#1e0010">倒入杯中</span> <span style="color:#f92672">-</span> <span style="color:#960050;background-color:#1e0010">加入辅料</span>

<span style="color:#960050;background-color:#1e0010">利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</span>

<span style="color:#ae81ff">1545985945198</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#75715e">//抽象制作饮品
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractDrinking</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#75715e">//烧水
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Boil() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#75715e">//冲泡
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Brew</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#75715e">//倒入杯中
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PourInCup</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#75715e">//加入辅料
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PutSomething</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#75715e">//规定流程
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MakeDrink</span>() {
		Boil();
		Brew();
		PourInCup();
		PutSomething();
	}
};

<span style="color:#75715e">//制作咖啡
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Coffee</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> AbstractDrinking {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#75715e">//烧水
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Boil() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;煮农夫山泉!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//冲泡
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Brew</span>() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;冲泡咖啡!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//倒入杯中
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PourInCup</span>() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;将咖啡倒入杯中!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//加入辅料
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PutSomething</span>() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;加入牛奶!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};

<span style="color:#75715e">//制作茶水
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Tea</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> AbstractDrinking {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#75715e">//烧水
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Boil() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;煮自来水!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//冲泡
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Brew</span>() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;冲泡茶叶!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//倒入杯中
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PourInCup</span>() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;将茶水倒入杯中!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#75715e">//加入辅料
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PutSomething</span>() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;加入枸杞!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};

<span style="color:#75715e">//业务函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DoWork</span>(AbstractDrinking<span style="color:#f92672">*</span> drink) {
	drink<span style="color:#f92672">-&gt;</span>MakeDrink();
	<span style="color:#66d9ef">delete</span> drink;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>() {
	DoWork(<span style="color:#66d9ef">new</span> Coffee);
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;--------------&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	DoWork(<span style="color:#66d9ef">new</span> Tea);
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```####</span> <span style="color:#ae81ff">4.7.5</span> <span style="color:#960050;background-color:#1e0010">虚析构和纯虚析构</span>
<span style="color:#960050;background-color:#1e0010">多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</span>

<span style="color:#960050;background-color:#1e0010">解决方式：将父类中的析构函数改为</span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">虚析构</span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">或者</span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">纯虚析构</span><span style="color:#f92672">*</span>

<span style="color:#960050;background-color:#1e0010">虚析构和纯虚析构共性：</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">可以解决父类指针释放子类对象</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">都需要有具体的函数实现</span>

<span style="color:#960050;background-color:#1e0010">虚析构和纯虚析构区别：</span>
<span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">如果是纯虚析构，该类属于抽象类，无法实例化对象</span>

<span style="color:#960050;background-color:#1e0010">虚析构语法：</span>

<span style="color:#960050;background-color:#1e0010">`</span><span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span><span style="color:#960050;background-color:#1e0010">类名</span>(){}<span style="color:#960050;background-color:#1e0010">`</span>

<span style="color:#960050;background-color:#1e0010">纯虚析构语法：</span>

<span style="color:#960050;background-color:#1e0010">`</span> <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span><span style="color:#960050;background-color:#1e0010">类名</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#960050;background-color:#1e0010">`</span>

<span style="color:#960050;background-color:#1e0010">`类名</span><span style="color:#f92672">::~</span><span style="color:#960050;background-color:#1e0010">类名</span>(){}<span style="color:#960050;background-color:#1e0010">`</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Animal</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>

	Animal()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Animal 构造函数调用！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Speak</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#75715e">//析构函数加上virtual关键字，变成虚析构函数
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//virtual ~Animal()
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//{
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//	cout &lt;&lt; &#34;Animal虚析构函数调用！&#34; &lt;&lt; endl;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//}
</span><span style="color:#75715e"></span>

	<span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Animal() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
};

Animal<span style="color:#f92672">::~</span>Animal()
{
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Animal 纯虚析构函数调用！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#75715e">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Animal {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Cat(string name)
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Cat构造函数调用！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
		m_Name <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> string(name);
	}
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Speak</span>()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>m_Name <span style="color:#f92672">&lt;&lt;</span>  <span style="color:#e6db74">&#34;小猫在说话!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#f92672">~</span>Cat()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Cat析构函数调用!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
		<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>m_Name <span style="color:#f92672">!=</span> NULL) {
			<span style="color:#66d9ef">delete</span> m_Name;
			m_Name <span style="color:#f92672">=</span> NULL;
		}
	}

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	string <span style="color:#f92672">*</span>m_Name;
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	Animal <span style="color:#f92672">*</span>animal <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Cat(<span style="color:#e6db74">&#34;Tom&#34;</span>);
	animal<span style="color:#f92672">-&gt;</span>Speak();

	<span style="color:#75715e">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//怎么解决？给基类增加一个虚析构函数
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//虚析构函数就是用来解决通过父类指针释放子类对象
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">delete</span> animal;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>总结：</p>
<pre><code>1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象

2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构

3. 拥有纯虚析构函数的类也属于抽象类
</code></pre>
<h4 id="476-多态案例三-电脑组装">4.7.6 多态案例三-电脑组装<a hidden class="anchor" aria-hidden="true" href="#476-多态案例三-电脑组装">#</a></h4>
<p><em>案例描述：</em></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#75715e">//抽象CPU类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CPU</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#75715e">//抽象的计算函数
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> calculate() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
};

<span style="color:#75715e">//抽象显卡类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VideoCard</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#75715e">//抽象的显示函数
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> display() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
};

<span style="color:#75715e">//抽象内存条类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Memory</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#75715e">//抽象的存储函数
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> storage() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
};

<span style="color:#75715e">//电脑类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Computer</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Computer(CPU <span style="color:#f92672">*</span> cpu, VideoCard <span style="color:#f92672">*</span> vc, Memory <span style="color:#f92672">*</span> mem)
	{
		m_cpu <span style="color:#f92672">=</span> cpu;
		m_vc <span style="color:#f92672">=</span> vc;
		m_mem <span style="color:#f92672">=</span> mem;
	}

	<span style="color:#75715e">//提供工作的函数
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">work</span>()
	{
		<span style="color:#75715e">//让零件工作起来，调用接口
</span><span style="color:#75715e"></span>		m_cpu<span style="color:#f92672">-&gt;</span>calculate();

		m_vc<span style="color:#f92672">-&gt;</span>display();

		m_mem<span style="color:#f92672">-&gt;</span>storage();
	}

	<span style="color:#75715e">//提供析构函数 释放3个电脑零件
</span><span style="color:#75715e"></span>	<span style="color:#f92672">~</span>Computer()
	{

		<span style="color:#75715e">//释放CPU零件
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (m_cpu <span style="color:#f92672">!=</span> NULL)
		{
			<span style="color:#66d9ef">delete</span> m_cpu;
			m_cpu <span style="color:#f92672">=</span> NULL;
		}

		<span style="color:#75715e">//释放显卡零件
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (m_vc <span style="color:#f92672">!=</span> NULL)
		{
			<span style="color:#66d9ef">delete</span> m_vc;
			m_vc <span style="color:#f92672">=</span> NULL;
		}

		<span style="color:#75715e">//释放内存条零件
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (m_mem <span style="color:#f92672">!=</span> NULL)
		{
			<span style="color:#66d9ef">delete</span> m_mem;
			m_mem <span style="color:#f92672">=</span> NULL;
		}
	}

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>

	CPU <span style="color:#f92672">*</span> m_cpu; <span style="color:#75715e">//CPU的零件指针
</span><span style="color:#75715e"></span>	VideoCard <span style="color:#f92672">*</span> m_vc; <span style="color:#75715e">//显卡零件指针
</span><span style="color:#75715e"></span>	Memory <span style="color:#f92672">*</span> m_mem; <span style="color:#75715e">//内存条零件指针
</span><span style="color:#75715e"></span>};

<span style="color:#75715e">//具体厂商
</span><span style="color:#75715e">//Intel厂商
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IntelCPU</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CPU
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> calculate()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Intel的CPU开始计算了！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IntelVideoCard</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> VideoCard
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> display()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Intel的显卡开始显示了！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IntelMemory</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Memory
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> storage()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Intel的内存条开始存储了！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};

<span style="color:#75715e">//Lenovo厂商
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LenovoCPU</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> CPU
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> calculate()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Lenovo的CPU开始计算了！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LenovoVideoCard</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> VideoCard
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> display()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Lenovo的显卡开始显示了！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LenovoMemory</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Memory
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> storage()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Lenovo的内存条开始存储了！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
};


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	<span style="color:#75715e">//第一台电脑零件
</span><span style="color:#75715e"></span>	CPU <span style="color:#f92672">*</span> intelCpu <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> IntelCPU;
	VideoCard <span style="color:#f92672">*</span> intelCard <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> IntelVideoCard;
	Memory <span style="color:#f92672">*</span> intelMem <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> IntelMemory;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;第一台电脑开始工作：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#75715e">//创建第一台电脑
</span><span style="color:#75715e"></span>	Computer <span style="color:#f92672">*</span> computer1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Computer(intelCpu, intelCard, intelMem);
	computer1<span style="color:#f92672">-&gt;</span>work();
	<span style="color:#66d9ef">delete</span> computer1;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;-----------------------&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;第二台电脑开始工作：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#75715e">//第二台电脑组装
</span><span style="color:#75715e"></span>	Computer <span style="color:#f92672">*</span> computer2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Computer(<span style="color:#66d9ef">new</span> LenovoCPU, <span style="color:#66d9ef">new</span> LenovoVideoCard, <span style="color:#66d9ef">new</span> LenovoMemory);;
	computer2<span style="color:#f92672">-&gt;</span>work();
	<span style="color:#66d9ef">delete</span> computer2;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;-----------------------&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;第三台电脑开始工作：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#75715e">//第三台电脑组装
</span><span style="color:#75715e"></span>	Computer <span style="color:#f92672">*</span> computer3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Computer(<span style="color:#66d9ef">new</span> LenovoCPU, <span style="color:#66d9ef">new</span> IntelVideoCard, <span style="color:#66d9ef">new</span> LenovoMemory);;
	computer3<span style="color:#f92672">-&gt;</span>work();
	<span style="color:#66d9ef">delete</span> computer3;

}
<span style="color:#960050;background-color:#1e0010">​```##</span> <span style="color:#ae81ff">5</span> <span style="color:#960050;background-color:#1e0010">文件操作</span>
<span style="color:#960050;background-color:#1e0010">程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</span>

<span style="color:#960050;background-color:#1e0010">通过</span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">文件可以将数据持久化</span><span style="color:#f92672">*</span>

C<span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">中对文件操作需要包含头文件</span> <span style="color:#f92672">==&lt;</span> fstream <span style="color:#f92672">&gt;==</span>

<span style="color:#960050;background-color:#1e0010">文件类型分为两种：</span>
<span style="color:#ae81ff">1.</span> <span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">文本文件</span><span style="color:#f92672">*</span>     <span style="color:#f92672">-</span>  <span style="color:#960050;background-color:#1e0010">文件以文本的</span><span style="color:#f92672">*</span>ASCII码<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">形式存储在计算机中</span>
<span style="color:#ae81ff">2.</span> <span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">二进制文件</span><span style="color:#f92672">*</span> <span style="color:#f92672">-</span>  <span style="color:#960050;background-color:#1e0010">文件以文本的</span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">二进制</span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">形式存储在计算机中，用户一般不能直接读懂它们</span>

<span style="color:#960050;background-color:#1e0010">操作文件的三大类</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">1.</span> ofstream<span style="color:#960050;background-color:#1e0010">：写操作</span>
<span style="color:#ae81ff">2.</span> ifstream<span style="color:#960050;background-color:#1e0010">：</span> <span style="color:#960050;background-color:#1e0010">读操作</span>
<span style="color:#ae81ff">3.</span> fstream <span style="color:#960050;background-color:#1e0010">：</span> <span style="color:#960050;background-color:#1e0010">读写操作</span>
<span style="color:#75715e">### 5.1文本文件
</span><span style="color:#75715e">#### 5.1.1写文件
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">写文件步骤如下：</span>
<span style="color:#ae81ff">1.</span> 
<span style="color:#960050;background-color:#1e0010">包含头文件</span>

<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fstream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#ae81ff">2.</span> 
<span style="color:#960050;background-color:#1e0010">创建流对象</span>

ofstream ofs;

<span style="color:#ae81ff">3.</span> 
<span style="color:#960050;background-color:#1e0010">打开文件</span>

ofs.open(<span style="color:#e6db74">&#34;文件路径&#34;</span>,<span style="color:#960050;background-color:#1e0010">打开方式</span>);

<span style="color:#ae81ff">4.</span> 
<span style="color:#960050;background-color:#1e0010">写数据</span>

ofs <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;写入的数据&#34;</span>;

<span style="color:#ae81ff">5.</span> 
<span style="color:#960050;background-color:#1e0010">关闭文件</span>

ofs.close();




<span style="color:#960050;background-color:#1e0010">文件打开方式：</span>

<span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">打开方式</span>    <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">解释</span>                       <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> <span style="color:#f92672">-----------</span> <span style="color:#f92672">|</span> <span style="color:#f92672">--------------------------</span> <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> ios<span style="color:#f92672">::</span>in     <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">为读文件而打开文件</span>         <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> ios<span style="color:#f92672">::</span>out    <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">为写文件而打开文件</span>         <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> ios<span style="color:#f92672">::</span>ate    <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">初始位置：文件尾</span>           <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> ios<span style="color:#f92672">::</span>app    <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">追加方式写文件</span>             <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> ios<span style="color:#f92672">::</span>trunc  <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">如果文件存在先删除，再创建</span> <span style="color:#f92672">|</span>
<span style="color:#f92672">|</span> ios<span style="color:#f92672">::</span>binary <span style="color:#f92672">|</span> <span style="color:#960050;background-color:#1e0010">二进制方式</span>                 <span style="color:#f92672">|</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">注意：</span><span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">文件打开方式可以配合使用，利用</span><span style="color:#f92672">|</span><span style="color:#960050;background-color:#1e0010">操作符</span>

<span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">例如：</span><span style="color:#f92672">**</span><span style="color:#960050;background-color:#1e0010">用二进制方式写文件</span> <span style="color:#960050;background-color:#1e0010">`</span>ios<span style="color:#f92672">::</span>binary <span style="color:#f92672">|</span>  ios<span style="color:#f92672">::</span> out<span style="color:#960050;background-color:#1e0010">`</span>

<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">示例：</span><span style="color:#f92672">*</span>
<span style="color:#960050;background-color:#1e0010">​```</span>C<span style="color:#f92672">++</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fstream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> test01()
{
	ofstream ofs;
	ofs.open(<span style="color:#e6db74">&#34;test.txt&#34;</span>, ios<span style="color:#f92672">::</span>out);

	ofs <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;姓名：张三&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	ofs <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;性别：男&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	ofs <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;年龄：18&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;

	ofs.close();
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>总结：</p>
<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream  ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&laquo;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h4 id="512读文件">5.1.2读文件<a hidden class="anchor" aria-hidden="true" href="#512读文件">#</a></h4>
<p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<p>读文件步骤如下：
1.
包含头文件</p>
<p>#include <!-- raw HTML omitted --></p>
<ol start="2">
<li></li>
</ol>
<p>创建流对象</p>
<p>ifstream ifs;</p>
<ol start="3">
<li></li>
</ol>
<p>打开文件并判断文件是否打开成功</p>
<p>ifs.open(&ldquo;文件路径&rdquo;,打开方式);</p>
<ol start="4">
<li></li>
</ol>
<p>读数据</p>
<p>四种方式读取</p>
<ol start="5">
<li></li>
</ol>
<p>关闭文件</p>
<p>ifs.close();</p>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fstream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	ifstream ifs;
	ifs.open(<span style="color:#e6db74">&#34;test.txt&#34;</span>, ios<span style="color:#f92672">::</span>in);

	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ifs.is_open())
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;文件打开失败&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
		<span style="color:#66d9ef">return</span>;
	}

	<span style="color:#75715e">//第一种方式
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//char buf[1024] = { 0 };
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//while (ifs &gt;&gt; buf)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//{
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//	cout &lt;&lt; buf &lt;&lt; endl;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//}
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//第二种
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//char buf[1024] = { 0 };
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//while (ifs.getline(buf,sizeof(buf)))
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//{
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//	cout &lt;&lt; buf &lt;&lt; endl;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//}
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//第三种
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//string buf;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//while (getline(ifs, buf))
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//{
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//	cout &lt;&lt; buf &lt;&lt; endl;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//}
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">char</span> c;
	<span style="color:#66d9ef">while</span> ((c <span style="color:#f92672">=</span> ifs.get()) <span style="color:#f92672">!=</span> EOF)
	{
		cout <span style="color:#f92672">&lt;&lt;</span> c;
	}

	ifs.close();


}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>总结：</p>
<ul>
<li>读文件可以利用 ifstream  ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件</li>
</ul>
<h3 id="52-二进制文件">5.2 二进制文件<a hidden class="anchor" aria-hidden="true" href="#52-二进制文件">#</a></h3>
<p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 ==ios::binary==</p>
<h4 id="521-写文件">5.2.1 写文件<a hidden class="anchor" aria-hidden="true" href="#521-写文件">#</a></h4>
<p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><em>示例：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fstream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">char</span> m_Name[<span style="color:#ae81ff">64</span>];
	<span style="color:#66d9ef">int</span> m_Age;
};

<span style="color:#75715e">//二进制文件  写文件
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	<span style="color:#75715e">//1、包含头文件
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//2、创建输出流对象
</span><span style="color:#75715e"></span>	ofstream ofs(<span style="color:#e6db74">&#34;person.txt&#34;</span>, ios<span style="color:#f92672">::</span>out <span style="color:#f92672">|</span> ios<span style="color:#f92672">::</span>binary);
	
	<span style="color:#75715e">//3、打开文件
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//ofs.open(&#34;person.txt&#34;, ios::out | ios::binary);
</span><span style="color:#75715e"></span>
	Person p <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;张三&#34;</span>  , <span style="color:#ae81ff">18</span>};

	<span style="color:#75715e">//4、写文件
</span><span style="color:#75715e"></span>	ofs.write((<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>p, <span style="color:#66d9ef">sizeof</span>(p));

	<span style="color:#75715e">//5、关闭文件
</span><span style="color:#75715e"></span>	ofs.close();
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h4 id="522-读文件">5.2.2 读文件<a hidden class="anchor" aria-hidden="true" href="#522-读文件">#</a></h4>
<p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p>示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fstream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">char</span> m_Name[<span style="color:#ae81ff">64</span>];
	<span style="color:#66d9ef">int</span> m_Age;
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>()
{
	ifstream ifs(<span style="color:#e6db74">&#34;person.txt&#34;</span>, ios<span style="color:#f92672">::</span>in <span style="color:#f92672">|</span> ios<span style="color:#f92672">::</span>binary);
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ifs.is_open())
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;文件打开失败&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}

	Person p;
	ifs.read((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>p, <span style="color:#66d9ef">sizeof</span>(p));

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;姓名： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.m_Name <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; 年龄： &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.m_Age <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

	test01();

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#960050;background-color:#1e0010">​```</span><span style="color:#f92672">*</span> <span style="color:#960050;background-color:#1e0010">文件输入流对象</span> <span style="color:#960050;background-color:#1e0010">可以通过</span>read函数<span style="color:#960050;background-color:#1e0010">，以二进制方式读数据</span>
</code></pre></div>

  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="next" href="https://github.com/FreanJa/freanja.github.io/post/2021-07-02/">
    <span class="title">Next Page »</span>
    <br>
    <span>CN knowledge combing</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="https://github.com/FreanJa/freanja.github.io/">FreanJa&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
