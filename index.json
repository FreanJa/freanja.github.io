[{"content":" 本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。\n1 内存分区模型 C++程序在执行时，将内存大方向划分为4个区域\n 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收  内存四区意义：\n不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n1.1 程序运行前 在程序编译后，生成了exe可执行程序，*未执行该程序前*分为两个区域 *代码区：* 存放 CPU 执行的机器指令 代码区是*共享*的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 代码区是*只读*的，使其只读的原因是防止程序意外地修改了它的指令 *全局区：* 全局变量和静态变量存放在此. 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ==该区域的数据在程序结束后由操作系统释放==.  示例：\n//全局变量 int g_a = 10; int g_b = 10; //全局常量 const int c_g_a = 10; const int c_g_b = 10; int main() { //局部变量 \tint a = 10; int b = 10; //打印地址 \tcout \u0026lt;\u0026lt; \u0026#34;局部变量a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;局部变量b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局变量g_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;g_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局变量g_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;g_b \u0026lt;\u0026lt; endl; //静态变量 \tstatic int s_a = 10; static int s_b = 10; cout \u0026lt;\u0026lt; \u0026#34;静态变量s_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;s_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;静态变量s_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;s_b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;字符串常量地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;\u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;字符串常量地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;\u0026#34;hello world1\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局常量c_g_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_g_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局常量c_g_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_g_b \u0026lt;\u0026lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout \u0026lt;\u0026lt; \u0026#34;局部常量c_l_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_l_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;局部常量c_l_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_l_b \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 打印结果：\n1545017602518\n总结：\n C++中在程序运行前分为全局区和代码区 代码区特点是共享和只读 全局区中存放全局变量、静态变量、常量 常量区中存放 const修饰的全局常量 和 字符串常量  1.2 程序运行后 *栈区：* 由编译器自动分配释放, 存放函数的参数值,局部变量等 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放  示例：\nint * func() { int a = 10; return \u0026amp;a; } int main() { int *p = func(); cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } *堆区：* 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收 在C++中主要利用new在堆区开辟内存  示例：\nint* func() { int* a = new int(10); return a; } int main() { int *p = func(); cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n堆区数据由程序员管理开辟和释放\n堆区数据利用new关键字进行开辟内存\n1.3 new操作符 C++中利用==new==操作符在堆区开辟数据 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete== 语法：` new 数据类型` 利用new创建的数据，会返回该数据对应的类型的指针  示例1： 基本语法\nint* func() { int* a = new int(10); return a; } int main() { int *p = func(); cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; //利用delete释放堆区数据 \tdelete p; //cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; //报错，释放的空间不可访问  system(\u0026#34;pause\u0026#34;); return 0; } 示例2：开辟数组\n//堆区开辟数组 int main() { int* arr = new int[10]; for (int i = 0; i \u0026lt; 10; i++) { arr[i] = i + 100; } for (int i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; } //释放数组 delete 后加 [] \tdelete[] arr; system(\u0026#34;pause\u0026#34;); return 0; } ​```## 2 引用 ### 2.1 引用的基本使用 **作用： **给变量起别名 *语法：* `数据类型 \u0026amp;别名 = 原名` *示例：* ​```C++ int main() { int a = 10; int \u0026amp;b = a; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; b = 100; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } ​```### 2.2 引用注意事项 * 引用必须初始化 * 引用在初始化后，不可以改变 示例： ​```C++ int main() { int a = 10; int b = 20; //int \u0026amp;c; //错误，引用必须初始化 \tint \u0026amp;c = a; //一旦初始化后，就不可以更改 \tc = b; //这是赋值操作，不是更改引用  cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } ​```### 2.3 引用做函数参数 **作用：**函数传参时，可以利用引用的技术让形参修饰实参 **优点：**可以简化指针修改实参 *示例：* ​```C++ //1. 值传递 void mySwap01(int a, int b) { int temp = a; a = b; b = temp; } //2. 地址传递 void mySwap02(int* a, int* b) { int temp = *a; *a = *b; *b = temp; } //3. 引用传递 void mySwap03(int\u0026amp; a, int\u0026amp; b) { int temp = a; a = b; b = temp; } int main() { int a = 10; int b = 20; mySwap01(a, b); cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; mySwap02(\u0026amp;a, \u0026amp;b); cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; mySwap03(a, b); cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } ​```\u0026gt; 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单### 2.4 引用做函数返回值 作用：引用是可以作为函数的返回值存在的 注意：*不要返回局部变量引用* 用法：函数调用作为左值 *示例：* ​```C++ //返回局部变量引用 int\u0026amp; test01() { int a = 10; //局部变量 \treturn a; } //返回静态变量引用 int\u0026amp; test02() { static int a = 20; return a; } int main() { //不能返回局部变量的引用 \tint\u0026amp; ref = test01(); cout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; //如果函数做左值，那么必须返回引用 \tint\u0026amp; ref2 = test02(); cout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; test02() = 1000; cout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ref2 = \u0026#34; \u0026lt;\u0026lt; ref2 \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 2.5 引用的本质 本质：引用的本质在c++内部实现是一个指针常量.\n讲解示例：\n//发现是引用，转换为 int* const ref = \u0026amp;a; void func(int\u0026amp; ref){ ref = 100; // ref是引用，转换为*ref = 100 } int main(){ int a = 10; //自动转换为 int* const ref = \u0026amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 \tint\u0026amp; ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;  cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ref:\u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; func(a); return 0; } 结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n2.6 常量引用 **作用：**常量引用主要用来修饰形参，防止误操作\n在函数形参列表中，可以加==const修饰形参==，防止形参改变实参\n示例：\n//引用使用的场景，通常用来修饰形参 void showValue(const int\u0026amp; v) { //v += 10; \tcout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; } int main() { //int\u0026amp; ref = 10; 引用本身需要一个合法的内存空间，因此这行错误 \t//加入const就可以了，编译器优化代码，int temp = 10; const int\u0026amp; ref = temp; \tconst int\u0026amp; ref = 10; //ref = 100; //加入const后不可以修改变量 \tcout \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; //函数中利用常量引用防止误操作修改实参 \tint a = 10; showValue(a); system(\u0026#34;pause\u0026#34;); return 0; } ​```## 3 函数提高 ### 3.1 函数默认参数 在C++中，函数的形参列表中的形参是可以有默认值的。 语法：` 返回值类型 函数名 （参数= 默认值）{}` *示例：* ​```C++ int func(int a, int b = 10, int c = 10) { return a + b + c; } //1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值 //2. 如果函数声明有默认值，函数实现的时候就不能有默认参数 int func2(int a = 10, int b = 10); int func2(int a, int b) { return a + b; } int main() { cout \u0026lt;\u0026lt; \u0026#34;ret = \u0026#34; \u0026lt;\u0026lt; func(20, 20) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ret = \u0026#34; \u0026lt;\u0026lt; func(100) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } ​```### 3.2 函数占位参数 C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置 *语法：* `返回值类型 函数名 (数据类型){}` 在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术 *示例：* ​```C++ //函数占位参数 ，占位参数也可以有默认参数 void func(int a, int) { cout \u0026lt;\u0026lt; \u0026#34;this is func\u0026#34; \u0026lt;\u0026lt; endl; } int main() { func(10,10); //占位参数必须填补  system(\u0026#34;pause\u0026#34;); return 0; } ​```### 3.3 函数重载 #### 3.3.1 函数重载概述 **作用：**函数名可以相同，提高复用性 *函数重载满足条件：* * 同一个作用域下 * 函数名称相同 * 函数参数*类型不同* 或者 *个数不同* 或者 *顺序不同* *注意:* 函数的返回值不可以作为函数重载的条件 *示例：* ​```C++ //函数重载需要函数都在同一个作用域下 void func() { cout \u0026lt;\u0026lt; \u0026#34;func 的调用！\u0026#34; \u0026lt;\u0026lt; endl; } void func(int a) { cout \u0026lt;\u0026lt; \u0026#34;func (int a) 的调用！\u0026#34; \u0026lt;\u0026lt; endl; } void func(double a) { cout \u0026lt;\u0026lt; \u0026#34;func (double a)的调用！\u0026#34; \u0026lt;\u0026lt; endl; } void func(int a ,double b) { cout \u0026lt;\u0026lt; \u0026#34;func (int a ,double b) 的调用！\u0026#34; \u0026lt;\u0026lt; endl; } void func(double a ,int b) { cout \u0026lt;\u0026lt; \u0026#34;func (double a ,int b)的调用！\u0026#34; \u0026lt;\u0026lt; endl; } //函数返回值不可以作为函数重载条件 //int func(double a, int b) //{ //\tcout \u0026lt;\u0026lt; \u0026#34;func (double a ,int b)的调用！\u0026#34; \u0026lt;\u0026lt; endl; //}  int main() { func(); func(10); func(3.14); func(10,3.14); func(3.14 , 10); system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 3.3.2 函数重载注意事项 * 引用作为重载条件 * 函数重载碰到函数默认参数 *示例：* ​```C++ //函数重载注意事项 //1、引用作为重载条件  void func(int \u0026amp;a) { cout \u0026lt;\u0026lt; \u0026#34;func (int \u0026amp;a) 调用 \u0026#34; \u0026lt;\u0026lt; endl; } void func(const int \u0026amp;a) { cout \u0026lt;\u0026lt; \u0026#34;func (const int \u0026amp;a) 调用 \u0026#34; \u0026lt;\u0026lt; endl; } //2、函数重载碰到函数默认参数  void func2(int a, int b = 10) { cout \u0026lt;\u0026lt; \u0026#34;func2(int a, int b = 10) 调用\u0026#34; \u0026lt;\u0026lt; endl; } void func2(int a) { cout \u0026lt;\u0026lt; \u0026#34;func2(int a) 调用\u0026#34; \u0026lt;\u0026lt; endl; } int main() { int a = 10; func(a); //调用无const \tfunc(10);//调用有const  //func2(10); //碰到默认参数产生歧义，需要避免  system(\u0026#34;pause\u0026#34;); return 0; } ​```## *4* 类和对象 C++面向对象的三大特性为：==封装、继承、多态== C++认为==万事万物都皆为对象==，对象上有其属性和行为 *例如：* 人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌... 车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调... 具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类 ### 4.1 封装 #### 4.1.1 封装的意义 封装是C++面向对象三大特性之一 封装的意义： * 将属性和行为作为一个整体，表现生活中的事物 * 将属性和行为加以权限控制 *封装意义一：* 在设计类的时候，属性和行为写在一起，表现事物 *语法：* `class 类名{ 访问权限： 属性 / 行为 };` **示例1：**设计一个圆类，求圆的周长 *示例代码：* ​```C++ //圆周率 const double PI = 3.14; //1、封装的意义 //将属性和行为作为一个整体，用来表现生活中的事物  //封装一个圆类，求圆的周长 //class代表设计一个类，后面跟着的是类名 class Circle { public: //访问权限 公共的权限  //属性 \tint m_r;//半径  //行为 \t//获取到圆的周长 \tdouble calculateZC() { //2 * pi * r \t//获取圆的周长 \treturn 2 * PI * m_r; } }; int main() { //通过圆类，创建圆的对象 \t// c1就是一个具体的圆 \tCircle c1; c1.m_r = 10; //给圆对象的半径 进行赋值操作  //2 * pi * 10 = = 62.8 \tcout \u0026lt;\u0026lt; \u0026#34;圆的周长为： \u0026#34; \u0026lt;\u0026lt; c1.calculateZC() \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } **示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号\n示例2代码：\n//学生类 class Student { public: void setName(string name) { m_name = name; } void setID(int id) { m_id = id; } void showStudent() { cout \u0026lt;\u0026lt; \u0026#34;name:\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34; ID:\u0026#34; \u0026lt;\u0026lt; m_id \u0026lt;\u0026lt; endl; } public: string m_name; int m_id; }; int main() { Student stu; stu.setName(\u0026#34;德玛西亚\u0026#34;); stu.setID(250); stu.showStudent(); system(\u0026#34;pause\u0026#34;); return 0; } 封装意义二：\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\n访问权限有三种：\n public 公共权限 protected 保护权限 private 私有权限  示例：\n//三种权限 //公共权限 public 类内可以访问 类外可以访问 //保护权限 protected 类内可以访问 类外不可以访问 //私有权限 private 类内可以访问 类外不可以访问  class Person { //姓名 公共权限 public: string m_Name; //汽车 保护权限 protected: string m_Car; //银行卡密码 私有权限 private: int m_Password; public: void func() { m_Name = \u0026#34;张三\u0026#34;; m_Car = \u0026#34;拖拉机\u0026#34;; m_Password = 123456; } }; int main() { Person p; p.m_Name = \u0026#34;李四\u0026#34;; //p.m_Car = \u0026#34;奔驰\u0026#34;; //保护权限类外访问不到 \t//p.m_Password = 123; //私有权限类外访问不到  system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.1.2 struct和class区别 在C++中 struct和class唯一的*区别*就在于 *默认的访问权限不同* 区别： * struct 默认权限为公共 * class 默认权限为私有 ​```C++ class C1 { int m_A; //默认是私有权限 }; struct C2 { int m_A; //默认是公共权限 }; int main() { C1 c1; c1.m_A = 10; //错误，访问权限是私有  C2 c2; c2.m_A = 10; //正确，访问权限是公共  system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.1.3 成员属性设置为私有 **优点1：**将所有成员属性设置为私有，可以自己控制读写权限 **优点2：**对于写权限，我们可以检测数据的有效性 *示例：* ​```C++ class Person { public: //姓名设置可读可写 \tvoid setName(string name) { m_Name = name; } string getName() { return m_Name; } //获取年龄 \tint getAge() { return m_Age; } //设置年龄 \tvoid setAge(int age) { if (age \u0026lt; 0 || age \u0026gt; 150) { cout \u0026lt;\u0026lt; \u0026#34;你个老妖精!\u0026#34; \u0026lt;\u0026lt; endl; return; } m_Age = age; } //情人设置为只写 \tvoid setLover(string lover) { m_Lover = lover; } private: string m_Name; //可读可写 姓名 \tint m_Age; //只读 年龄  string m_Lover; //只写 情人 }; int main() { Person p; //姓名设置 \tp.setName(\u0026#34;张三\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.getName() \u0026lt;\u0026lt; endl; //年龄设置 \tp.setAge(50); cout \u0026lt;\u0026lt; \u0026#34;年龄： \u0026#34; \u0026lt;\u0026lt; p.getAge() \u0026lt;\u0026lt; endl; //情人设置 \tp.setLover(\u0026#34;苍井\u0026#34;); //cout \u0026lt;\u0026lt; \u0026#34;情人： \u0026#34; \u0026lt;\u0026lt; p.m_Lover \u0026lt;\u0026lt; endl; //只写属性，不可以读取  system(\u0026#34;pause\u0026#34;); return 0; } 练习案例1：设计立方体类\n设计立方体类(Cube)\n求出立方体的面积和体积\n分别用全局函数和成员函数判断两个立方体是否相等。\n1545533548532\n练习案例2：点和圆的关系\n设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。\n1545533829184\n4.2 对象的初始化和清理  生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全 C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。  4.2.1 构造函数和析构函数 对象的初始化和清理也是两个非常重要的安全问题\n一个对象或者变量没有初始状态，对其使用后果是未知 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题  c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供\n编译器提供的构造函数和析构函数是空实现。\n 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。  构造函数语法：类名(){}\n 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次  析构函数语法： ~类名(){}\n 析构函数，没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次  class Person { public: //构造函数 \tPerson() { cout \u0026lt;\u0026lt; \u0026#34;Person的构造函数调用\u0026#34; \u0026lt;\u0026lt; endl; } //析构函数 \t~Person() { cout \u0026lt;\u0026lt; \u0026#34;Person的析构函数调用\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { Person p; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.2.2 构造函数的分类及调用 两种分类方式： 按参数分为： 有参构造和无参构造 按类型分为： 普通构造和拷贝构造 三种调用方式： 括号法 显示法 隐式转换法 *示例：* ​```C++ //1、构造函数分类 // 按照参数分类分为 有参和无参构造 无参又称为默认构造函数 // 按照类型分类分为 普通构造和拷贝构造  class Person { public: //无参（默认）构造函数 \tPerson() { cout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //有参构造函数 \tPerson(int a) { age = a; cout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //拷贝构造函数 \tPerson(const Person\u0026amp; p) { age = p.age; cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //析构函数 \t~Person() { cout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; } public: int age; }; //2、构造函数的调用 //调用无参构造函数 void test01() { Person p; //调用无参构造函数 } //调用有参的构造函数 void test02() { //2.1 括号法，常用 \tPerson p1(10); //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 \t//Person p2();  //2.2 显式法 \tPerson p2 = Person(10); Person p3 = Person(p2); //Person(10)单独写就是匿名对象 当前行结束之后，马上析构  //2.3 隐式转换法 \tPerson p4 = 10; // Person p4 = Person(10); \tPerson p5 = p4; // Person p5 = Person(p4);  //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 \t//Person p5(p4); } int main() { test01(); //test02();  system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.2.3 拷贝构造函数调用时机 C++中拷贝构造函数调用时机通常有三种情况 * 使用一个已经创建完毕的对象来初始化一个新对象 * 值传递的方式给函数参数传值 * 以值方式返回局部对象 *示例：* ​```C++ class Person { public: Person() { cout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; mAge = 0; } Person(int age) { cout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; mAge = age; } Person(const Person\u0026amp; p) { cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; mAge = p.mAge; } //析构函数在释放内存之前调用 \t~Person() { cout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; } public: int mAge; }; //1. 使用一个已经创建完毕的对象来初始化一个新对象 void test01() { Person man(100); //p对象已经创建完毕 \tPerson newman(man); //调用拷贝构造函数 \tPerson newman2 = man; //拷贝构造  //Person newman3; \t//newman3 = man; //不是调用拷贝构造函数，赋值操作 } //2. 值传递的方式给函数参数传值 //相当于Person p1 = p; void doWork(Person p1) {} void test02() { Person p; //无参构造函数 \tdoWork(p); } //3. 以值方式返回局部对象 Person doWork2() { Person p1; cout \u0026lt;\u0026lt; (int *)\u0026amp;p1 \u0026lt;\u0026lt; endl; return p1; } void test03() { Person p = doWork2(); cout \u0026lt;\u0026lt; (int *)\u0026amp;p \u0026lt;\u0026lt; endl; } int main() { //test01(); \t//test02(); \ttest03(); system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.2.4 构造函数调用规则 默认情况下，c++编译器至少给一个类添加3个函数 1．默认构造函数(无参，函数体为空) 2．默认析构函数(无参，函数体为空) 3．默认拷贝构造函数，对属性进行值拷贝 构造函数调用规则如下： * 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造 * 如果用户定义拷贝构造函数，c++不会再提供其他构造函数 示例： ​```C++ class Person { public: //无参（默认）构造函数 \tPerson() { cout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //有参构造函数 \tPerson(int a) { age = a; cout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //拷贝构造函数 \tPerson(const Person\u0026amp; p) { age = p.age; cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //析构函数 \t~Person() { cout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; } public: int age; }; void test01() { Person p1(18); //如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作 \tPerson p2(p1); cout \u0026lt;\u0026lt; \u0026#34;p2的年龄为： \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; endl; } void test02() { //如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造 \tPerson p1; //此时如果用户自己没有提供默认构造，会出错 \tPerson p2(10); //用户提供的有参 \tPerson p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供  //如果用户提供拷贝构造，编译器不会提供其他构造函数 \tPerson p4; //此时如果用户自己没有提供默认构造，会出错 \tPerson p5(10); //此时如果用户自己没有提供有参，会出错 \tPerson p6(p5); //用户自己提供拷贝构造 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.2.5 深拷贝与浅拷贝 深浅拷贝是面试经典问题，也是常见的一个坑 浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间，进行拷贝操作 *示例：* ​```C++ class Person { public: //无参（默认）构造函数 \tPerson() { cout \u0026lt;\u0026lt; \u0026#34;无参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } //有参构造函数 \tPerson(int age ,int height) { cout \u0026lt;\u0026lt; \u0026#34;有参构造函数!\u0026#34; \u0026lt;\u0026lt; endl; m_age = age; m_height = new int(height); } //拷贝构造函数 \tPerson(const Person\u0026amp; p) { cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数!\u0026#34; \u0026lt;\u0026lt; endl; //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 \tm_age = p.m_age; m_height = new int(*p.m_height); } //析构函数 \t~Person() { cout \u0026lt;\u0026lt; \u0026#34;析构函数!\u0026#34; \u0026lt;\u0026lt; endl; if (m_height != NULL) { delete m_height; } } public: int m_age; int* m_height; }; void test01() { Person p1(18, 180); Person p2(p1); cout \u0026lt;\u0026lt; \u0026#34;p1的年龄： \u0026#34; \u0026lt;\u0026lt; p1.m_age \u0026lt;\u0026lt; \u0026#34; 身高： \u0026#34; \u0026lt;\u0026lt; *p1.m_height \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p2的年龄： \u0026#34; \u0026lt;\u0026lt; p2.m_age \u0026lt;\u0026lt; \u0026#34; 身高： \u0026#34; \u0026lt;\u0026lt; *p2.m_height \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```\u0026gt; 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题#### 4.2.6 初始化列表 *作用：* C++提供了初始化列表语法，用来初始化属性 *语法：*`构造函数()：属性1(值1),属性2（值2）... {}` *示例：* ​```C++ class Person { public: ////传统方式初始化 \t//Person(int a, int b, int c) { \t//\tm_A = a; \t//\tm_B = b; \t//\tm_C = c; \t//}  //初始化列表方式初始化 \tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {} void PrintPerson() { cout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; m_A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;mB:\u0026#34; \u0026lt;\u0026lt; m_B \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;mC:\u0026#34; \u0026lt;\u0026lt; m_C \u0026lt;\u0026lt; endl; } private: int m_A; int m_B; int m_C; }; int main() { Person p(1, 2, 3); p.PrintPerson(); system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.2.7 类对象作为类成员 C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员 例如： ​```C++ class A {} class B { A a； } B类中有对象A作为成员，A为对象成员\n那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？\n示例：\nclass Phone { public: Phone(string name) { m_PhoneName = name; cout \u0026lt;\u0026lt; \u0026#34;Phone构造\u0026#34; \u0026lt;\u0026lt; endl; } ~Phone() { cout \u0026lt;\u0026lt; \u0026#34;Phone析构\u0026#34; \u0026lt;\u0026lt; endl; } string m_PhoneName; }; class Person { public: //初始化列表可以告诉编译器调用哪一个构造函数 \tPerson(string name, string pName) :m_Name(name), m_Phone(pName) { cout \u0026lt;\u0026lt; \u0026#34;Person构造\u0026#34; \u0026lt;\u0026lt; endl; } ~Person() { cout \u0026lt;\u0026lt; \u0026#34;Person析构\u0026#34; \u0026lt;\u0026lt; endl; } void playGame() { cout \u0026lt;\u0026lt; m_Name \u0026lt;\u0026lt; \u0026#34; 使用\u0026#34; \u0026lt;\u0026lt; m_Phone.m_PhoneName \u0026lt;\u0026lt; \u0026#34; 牌手机! \u0026#34; \u0026lt;\u0026lt; endl; } string m_Name; Phone m_Phone; }; void test01() { //当类中成员是其他类对象时，我们称该成员为 对象成员 \t//构造的顺序是 ：先调用对象成员的构造，再调用本类构造 \t//析构顺序与构造相反 \tPerson p(\u0026#34;张三\u0026#34; , \u0026#34;苹果X\u0026#34;); p.playGame(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.2.8 静态成员 静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为： * 静态成员变量 * 所有对象共享同一份数据 * 在编译阶段分配内存 * 类内声明，类外初始化 * 静态成员函数 * 所有对象共享同一个函数 * 静态成员函数只能访问静态成员变量 **示例1 ：**静态成员变量 ​```C++ class Person { public: static int m_A; //静态成员变量  //静态成员变量特点： \t//1 在编译阶段分配内存 \t//2 类内声明，类外初始化 \t//3 所有对象共享同一份数据  private: static int m_B; //静态成员变量也是有访问权限的 }; int Person::m_A = 10; int Person::m_B = 10; void test01() { //静态成员变量两种访问方式  //1、通过对象 \tPerson p1; p1.m_A = 100; cout \u0026lt;\u0026lt; \u0026#34;p1.m_A = \u0026#34; \u0026lt;\u0026lt; p1.m_A \u0026lt;\u0026lt; endl; Person p2; p2.m_A = 200; cout \u0026lt;\u0026lt; \u0026#34;p1.m_A = \u0026#34; \u0026lt;\u0026lt; p1.m_A \u0026lt;\u0026lt; endl; //共享同一份数据 \tcout \u0026lt;\u0026lt; \u0026#34;p2.m_A = \u0026#34; \u0026lt;\u0026lt; p2.m_A \u0026lt;\u0026lt; endl; //2、通过类名 \tcout \u0026lt;\u0026lt; \u0026#34;m_A = \u0026#34; \u0026lt;\u0026lt; Person::m_A \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026#34;m_B = \u0026#34; \u0026lt;\u0026lt; Person::m_B \u0026lt;\u0026lt; endl; //私有权限访问不到 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } **示例2：**静态成员函数\nclass Person { public: //静态成员函数特点： \t//1 程序共享一个函数 \t//2 静态成员函数只能访问静态成员变量 \tstatic void func() { cout \u0026lt;\u0026lt; \u0026#34;func调用\u0026#34; \u0026lt;\u0026lt; endl; m_A = 100; //m_B = 100; //错误，不可以访问非静态成员变量 \t} static int m_A; //静态成员变量 \tint m_B; // private: //静态成员函数也是有访问权限的 \tstatic void func2() { cout \u0026lt;\u0026lt; \u0026#34;func2调用\u0026#34; \u0026lt;\u0026lt; endl; } }; int Person::m_A = 10; void test01() { //静态成员变量两种访问方式  //1、通过对象 \tPerson p1; p1.func(); //2、通过类名 \tPerson::func(); //Person::func2(); //私有权限访问不到 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```### 4.3 C++对象模型和this指针 #### 4.3.1 成员变量和成员函数分开存储 在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 ​```C++ class Person { public: Person() { mA = 0; } //非静态成员变量占对象空间 \tint mA; //静态成员变量不占对象空间 \tstatic int mB; //函数也不占对象空间，所有函数共享一个函数实例 \tvoid func() { cout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;mA \u0026lt;\u0026lt; endl; } //静态成员函数也不占对象空间 \tstatic void sfunc() { } }; int main() { cout \u0026lt;\u0026lt; sizeof(Person) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.3.2 this指针概念 通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是：这一块代码是如何区分那个对象调用自己的呢？ c++通过提供特殊的对象指针，this指针，解决上述问题。*this指针指向被调用的成员函数所属的对象* this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义，直接使用即可 this指针的用途： * 当形参和成员变量同名时，可用this指针来区分 * 在类的非静态成员函数中返回对象本身，可使用return *this ​```C++ class Person { public: Person(int age) { //1、当形参和成员变量同名时，可用this指针来区分 \tthis-\u0026gt;age = age; } Person\u0026amp; PersonAddPerson(Person p) { this-\u0026gt;age += p.age; //返回对象本身 \treturn *this; } int age; }; void test01() { Person p1(10); cout \u0026lt;\u0026lt; \u0026#34;p1.age = \u0026#34; \u0026lt;\u0026lt; p1.age \u0026lt;\u0026lt; endl; Person p2(10); p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1); cout \u0026lt;\u0026lt; \u0026#34;p2.age = \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.3.3 空指针访问成员函数 C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 *示例：* ​```C++ //空指针访问成员函数 class Person { public: void ShowClassName() { cout \u0026lt;\u0026lt; \u0026#34;我是Person类!\u0026#34; \u0026lt;\u0026lt; endl; } void ShowPerson() { if (this == NULL) { return; } cout \u0026lt;\u0026lt; mAge \u0026lt;\u0026lt; endl; } public: int mAge; }; void test01() { Person * p = NULL; p-\u0026gt;ShowClassName(); //空指针，可以调用成员函数 \tp-\u0026gt;ShowPerson(); //但是如果成员函数中用到了this指针，就不可以了 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.3.4 const修饰成员函数 *常函数：* * 成员函数后加const后我们称为这个函数为*常函数* * 常函数内不可以修改成员属性 * 成员属性声明时加关键字mutable后，在常函数中依然可以修改 *常对象：* * 声明对象前加const称该对象为常对象 * 常对象只能调用常函数 *示例：* ​```C++ class Person { public: Person() { m_A = 0; m_B = 0; } //this指针的本质是一个指针常量，指针的指向不可修改 \t//如果想让指针指向的值也不可以修改，需要声明常函数 \tvoid ShowPerson() const { //const Type* const pointer; \t//this = NULL; //不能修改指针的指向 Person* const this; \t//this-\u0026gt;mA = 100; //但是this指针指向的对象的数据是可以修改的  //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 \tthis-\u0026gt;m_B = 100; } void MyFunc() const { //mA = 10000; \t} public: int m_A; mutable int m_B; //可修改 可变的 }; //const修饰对象 常对象 void test01() { const Person person; //常量对象 \tcout \u0026lt;\u0026lt; person.m_A \u0026lt;\u0026lt; endl; //person.mA = 100; //常对象不能修改成员变量的值,但是可以访问 \tperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量  //常对象访问成员函数 \tperson.MyFunc(); //常对象不能调用const的函数  } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```### 4.4 友元 生活中你的家有客厅(Public)，有你的卧室(Private) 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜好基友进去。 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元的目的就是让一个函数或者类 访问另一个类中私有成员 友元的关键字为 ==friend== 友元的三种实现 * 全局函数做友元 * 类做友元 * 成员函数做友元 #### 4.4.1 全局函数做友元 ​```C++ class Building { //告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容 \tfriend void goodGay(Building * building); public: Building() { this-\u0026gt;m_SittingRoom = \u0026#34;客厅\u0026#34;; this-\u0026gt;m_BedRoom = \u0026#34;卧室\u0026#34;; } public: string m_SittingRoom; //客厅  private: string m_BedRoom; //卧室 }; void goodGay(Building * building) { cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问： \u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问： \u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; } void test01() { Building b; goodGay(\u0026amp;b); } int main(){ test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.4.2 类做友元 ​```C++ class Building; class goodGay { public: goodGay(); void visit(); private: Building *building; }; class Building { //告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容 \tfriend class goodGay; public: Building(); public: string m_SittingRoom; //客厅 private: string m_BedRoom;//卧室 }; Building::Building() { this-\u0026gt;m_SittingRoom = \u0026#34;客厅\u0026#34;; this-\u0026gt;m_BedRoom = \u0026#34;卧室\u0026#34;; } goodGay::goodGay() { building = new Building; } void goodGay::visit() { cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; } void test01() { goodGay gg; gg.visit(); } int main(){ test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.4.3 成员函数做友元 ​```C++ class Building; class goodGay { public: goodGay(); void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容 \tvoid visit2(); private: Building *building; }; class Building { //告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 \tfriend void goodGay::visit(); public: Building(); public: string m_SittingRoom; //客厅 private: string m_BedRoom;//卧室 }; Building::Building() { this-\u0026gt;m_SittingRoom = \u0026#34;客厅\u0026#34;; this-\u0026gt;m_BedRoom = \u0026#34;卧室\u0026#34;; } goodGay::goodGay() { building = new Building; } void goodGay::visit() { cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; } void goodGay::visit2() { cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_SittingRoom \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; \u0026#34;好基友正在访问\u0026#34; \u0026lt;\u0026lt; building-\u0026gt;m_BedRoom \u0026lt;\u0026lt; endl; } void test01() { goodGay gg; gg.visit(); } int main(){ test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```### 4.5 运算符重载 运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 #### 4.5.1 加号运算符重载 作用：实现两个自定义数据类型相加的运算 ​```C++ class Person { public: Person() {}; Person(int a, int b) { this-\u0026gt;m_A = a; this-\u0026gt;m_B = b; } //成员函数实现 + 号运算符重载 \tPerson operator+(const Person\u0026amp; p) { Person temp; temp.m_A = this-\u0026gt;m_A + p.m_A; temp.m_B = this-\u0026gt;m_B + p.m_B; return temp; } public: int m_A; int m_B; }; //全局函数实现 + 号运算符重载 //Person operator+(const Person\u0026amp; p1, const Person\u0026amp; p2) { //\tPerson temp(0, 0); //\ttemp.m_A = p1.m_A + p2.m_A; //\ttemp.m_B = p1.m_B + p2.m_B; //\treturn temp; //}  //运算符重载 可以发生函数重载 Person operator+(const Person\u0026amp; p2, int val) { Person temp; temp.m_A = p2.m_A + val; temp.m_B = p2.m_B + val; return temp; } void test() { Person p1(10, 10); Person p2(20, 20); //成员函数方式 \tPerson p3 = p2 + p1; //相当于 p2.operaor+(p1) \tcout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; p3.m_A \u0026lt;\u0026lt; \u0026#34; mB:\u0026#34; \u0026lt;\u0026lt; p3.m_B \u0026lt;\u0026lt; endl; Person p4 = p3 + 10; //相当于 operator+(p3,10) \tcout \u0026lt;\u0026lt; \u0026#34;mA:\u0026#34; \u0026lt;\u0026lt; p4.m_A \u0026lt;\u0026lt; \u0026#34; mB:\u0026#34; \u0026lt;\u0026lt; p4.m_B \u0026lt;\u0026lt; endl; } int main() { test(); system(\u0026#34;pause\u0026#34;); return 0; } ​```\u0026gt; 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的\u0026gt; 总结2：不要滥用运算符重载#### 4.5.2 左移运算符重载 作用：可以输出自定义数据类型 ​```C++ class Person { friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, Person\u0026amp; p); public: Person(int a, int b) { this-\u0026gt;m_A = a; this-\u0026gt;m_B = b; } //成员函数 实现不了 p \u0026lt;\u0026lt; cout 不是我们想要的效果 \t//void operator\u0026lt;\u0026lt;(Person\u0026amp; p){ \t//}  private: int m_A; int m_B; }; //全局函数实现左移重载 //ostream对象只能有一个 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, Person\u0026amp; p) { out \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; p.m_A \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; p.m_B; return out; } void test() { Person p1(10, 20); cout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; //链式编程 } int main() { test(); system(\u0026#34;pause\u0026#34;); return 0; } ​```\u0026gt; 总结：重载左移运算符配合友元可以实现输出自定义数据类型#### 4.5.3 递增运算符重载 作用： 通过重载递增运算符，实现自己的整型数据 ​```C++ class MyInteger { friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, MyInteger myint); public: MyInteger() { m_Num = 0; } //前置++ \tMyInteger\u0026amp; operator++() { //先++ \tm_Num++; //再返回 \treturn *this; } //后置++ \tMyInteger operator++(int) { //先返回 \tMyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； \tm_Num++; return temp; } private: int m_Num; }; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; out, MyInteger myint) { out \u0026lt;\u0026lt; myint.m_Num; return out; } //前置++ 先++ 再返回 void test01() { MyInteger myInt; cout \u0026lt;\u0026lt; ++myInt \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; myInt \u0026lt;\u0026lt; endl; } //后置++ 先返回 再++ void test02() { MyInteger myInt; cout \u0026lt;\u0026lt; myInt++ \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; myInt \u0026lt;\u0026lt; endl; } int main() { test01(); //test02();  system(\u0026#34;pause\u0026#34;); return 0; } ​```\u0026gt; 总结： 前置递增返回引用，后置递增返回值#### 4.5.4 赋值运算符重载 c++编译器至少给一个类添加4个函数 1. 默认构造函数(无参，函数体为空) 2. 默认析构函数(无参，函数体为空) 3. 默认拷贝构造函数，对属性进行值拷贝 4. 赋值运算符 operator=, 对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题 *示例：* ​```C++ class Person { public: Person(int age) { //将年龄数据开辟到堆区 \tm_Age = new int(age); } //重载赋值运算符 \tPerson\u0026amp; operator=(Person \u0026amp;p) { if (m_Age != NULL) { delete m_Age; m_Age = NULL; } //编译器提供的代码是浅拷贝 \t//m_Age = p.m_Age;  //提供深拷贝 解决浅拷贝的问题 \tm_Age = new int(*p.m_Age); //返回自身 \treturn *this; } ~Person() { if (m_Age != NULL) { delete m_Age; m_Age = NULL; } } //年龄的指针 \tint *m_Age; }; void test01() { Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; //赋值操作  cout \u0026lt;\u0026lt; \u0026#34;p1的年龄为：\u0026#34; \u0026lt;\u0026lt; *p1.m_Age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p2的年龄为：\u0026#34; \u0026lt;\u0026lt; *p2.m_Age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p3的年龄为：\u0026#34; \u0026lt;\u0026lt; *p3.m_Age \u0026lt;\u0026lt; endl; } int main() { test01(); //int a = 10; \t//int b = 20; \t//int c = 30;  //c = b = a; \t//cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; \t//cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; \t//cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl;  system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.5.5 关系运算符重载 **作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作 *示例：* ​```C++ class Person { public: Person(string name, int age) { this-\u0026gt;m_Name = name; this-\u0026gt;m_Age = age; }; bool operator==(Person \u0026amp; p) { if (this-\u0026gt;m_Name == p.m_Name \u0026amp;\u0026amp; this-\u0026gt;m_Age == p.m_Age) { return true; } else { return false; } } bool operator!=(Person \u0026amp; p) { if (this-\u0026gt;m_Name == p.m_Name \u0026amp;\u0026amp; this-\u0026gt;m_Age == p.m_Age) { return false; } else { return true; } } string m_Name; int m_Age; }; void test01() { //int a = 0; \t//int b = 0;  Person a(\u0026#34;孙悟空\u0026#34;, 18); Person b(\u0026#34;孙悟空\u0026#34;, 18); if (a == b) { cout \u0026lt;\u0026lt; \u0026#34;a和b相等\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;a和b不相等\u0026#34; \u0026lt;\u0026lt; endl; } if (a != b) { cout \u0026lt;\u0026lt; \u0026#34;a和b不相等\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;a和b相等\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.5.6 函数调用运算符重载 * 函数调用运算符 () 也可以重载 * 由于重载后使用的方式非常像函数的调用，因此称为仿函数 * 仿函数没有固定写法，非常灵活 *示例：* ​```C++ class MyPrint { public: void operator()(string text) { cout \u0026lt;\u0026lt; text \u0026lt;\u0026lt; endl; } }; void test01() { //重载的（）操作符 也称为仿函数 \tMyPrint myFunc; myFunc(\u0026#34;hello world\u0026#34;); } class MyAdd { public: int operator()(int v1, int v2) { return v1 + v2; } }; void test02() { MyAdd add; int ret = add(10, 10); cout \u0026lt;\u0026lt; \u0026#34;ret = \u0026#34; \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; endl; //匿名对象调用 \tcout \u0026lt;\u0026lt; \u0026#34;MyAdd()(100,100) = \u0026#34; \u0026lt;\u0026lt; MyAdd()(100, 100) \u0026lt;\u0026lt; endl; } int main() { test01(); test02(); system(\u0026#34;pause\u0026#34;); return 0; } ​```### 4.6 继承 *继承是面向对象三大特性之一* 有些类与类之间存在特殊的关系，例如下图中： 1544861202252 我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。 这个时候我们就可以考虑利用继承的技术，减少重复代码 #### 4.6.1 继承的基本语法 例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同 接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处 *普通实现：* ​```C++ //Java页面 class Java { public: void header() { cout \u0026lt;\u0026lt; \u0026#34;首页、公开课、登录、注册...（公共头部）\u0026#34; \u0026lt;\u0026lt; endl; } void footer() { cout \u0026lt;\u0026lt; \u0026#34;帮助中心、交流合作、站内地图...(公共底部)\u0026#34; \u0026lt;\u0026lt; endl; } void left() { cout \u0026lt;\u0026lt; \u0026#34;Java,Python,C++...(公共分类列表)\u0026#34; \u0026lt;\u0026lt; endl; } void content() { cout \u0026lt;\u0026lt; \u0026#34;JAVA学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; //Python页面 class Python { public: void header() { cout \u0026lt;\u0026lt; \u0026#34;首页、公开课、登录、注册...（公共头部）\u0026#34; \u0026lt;\u0026lt; endl; } void footer() { cout \u0026lt;\u0026lt; \u0026#34;帮助中心、交流合作、站内地图...(公共底部)\u0026#34; \u0026lt;\u0026lt; endl; } void left() { cout \u0026lt;\u0026lt; \u0026#34;Java,Python,C++...(公共分类列表)\u0026#34; \u0026lt;\u0026lt; endl; } void content() { cout \u0026lt;\u0026lt; \u0026#34;Python学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; //C++页面 class CPP { public: void header() { cout \u0026lt;\u0026lt; \u0026#34;首页、公开课、登录、注册...（公共头部）\u0026#34; \u0026lt;\u0026lt; endl; } void footer() { cout \u0026lt;\u0026lt; \u0026#34;帮助中心、交流合作、站内地图...(公共底部)\u0026#34; \u0026lt;\u0026lt; endl; } void left() { cout \u0026lt;\u0026lt; \u0026#34;Java,Python,C++...(公共分类列表)\u0026#34; \u0026lt;\u0026lt; endl; } void content() { cout \u0026lt;\u0026lt; \u0026#34;C++学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { //Java页面 \tcout \u0026lt;\u0026lt; \u0026#34;Java下载视频页面如下： \u0026#34; \u0026lt;\u0026lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; //Python页面 \tcout \u0026lt;\u0026lt; \u0026#34;Python下载视频页面如下： \u0026#34; \u0026lt;\u0026lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; //C++页面 \tcout \u0026lt;\u0026lt; \u0026#34;C++下载视频页面如下： \u0026#34; \u0026lt;\u0026lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 继承实现：\n//公共页面 class BasePage { public: void header() { cout \u0026lt;\u0026lt; \u0026#34;首页、公开课、登录、注册...（公共头部）\u0026#34; \u0026lt;\u0026lt; endl; } void footer() { cout \u0026lt;\u0026lt; \u0026#34;帮助中心、交流合作、站内地图...(公共底部)\u0026#34; \u0026lt;\u0026lt; endl; } void left() { cout \u0026lt;\u0026lt; \u0026#34;Java,Python,C++...(公共分类列表)\u0026#34; \u0026lt;\u0026lt; endl; } }; //Java页面 class Java : public BasePage { public: void content() { cout \u0026lt;\u0026lt; \u0026#34;JAVA学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; //Python页面 class Python : public BasePage { public: void content() { cout \u0026lt;\u0026lt; \u0026#34;Python学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; //C++页面 class CPP : public BasePage { public: void content() { cout \u0026lt;\u0026lt; \u0026#34;C++学科视频\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { //Java页面 \tcout \u0026lt;\u0026lt; \u0026#34;Java下载视频页面如下： \u0026#34; \u0026lt;\u0026lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; //Python页面 \tcout \u0026lt;\u0026lt; \u0026#34;Python下载视频页面如下： \u0026#34; \u0026lt;\u0026lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; //C++页面 \tcout \u0026lt;\u0026lt; \u0026#34;C++下载视频页面如下： \u0026#34; \u0026lt;\u0026lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n继承的好处：==可以减少重复的代码==\nclass A : public B;\nA 类称为子类 或 派生类\nB 类称为父类 或 基类\n派生类中的成员，包含两大部分：\n一类是从基类继承过来的，一类是自己增加的成员。\n从基类继承过过来的表现其共性，而新增的成员体现了其个性。\n4.6.2 继承方式 继承的语法：class 子类 : 继承方式 父类\n继承方式一共有三种：\n 公共继承 保护继承 私有继承  img\n示例：\nclass Base1 { public: int m_A; protected: int m_B; private: int m_C; }; //公共继承 class Son1 :public Base1 { public: void func() { m_A; //可访问 public权限 \tm_B; //可访问 protected权限 \t//m_C; //不可访问 \t} }; void myClass() { Son1 s1; s1.m_A; //其他类只能访问到公共权限 } //保护继承 class Base2 { public: int m_A; protected: int m_B; private: int m_C; }; class Son2:protected Base2 { public: void func() { m_A; //可访问 protected权限 \tm_B; //可访问 protected权限 \t//m_C; //不可访问 \t} }; void myClass2() { Son2 s; //s.m_A; //不可访问 } //私有继承 class Base3 { public: int m_A; protected: int m_B; private: int m_C; }; class Son3:private Base3 { public: void func() { m_A; //可访问 private权限 \tm_B; //可访问 private权限 \t//m_C; //不可访问 \t} }; class GrandSon3 :public Son3 { public: void func() { //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 \t//m_A; \t//m_B; \t//m_C; \t} }; ​```#### 4.6.3 继承中的对象模型 **问题：**从父类继承过来的成员，哪些属于子类对象中？ *示例：* ​```C++ class Base { public: int m_A; protected: int m_B; private: int m_C; //私有成员只是被隐藏了，但是还是会继承下去 }; //公共继承 class Son :public Base { public: int m_D; }; void test01() { cout \u0026lt;\u0026lt; \u0026#34;sizeof Son = \u0026#34; \u0026lt;\u0026lt; sizeof(Son) \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 利用工具查看：\n1545881904150\n打开工具窗口后，定位到当前CPP文件的盘符\n然后输入： cl /d1 reportSingleClassLayout查看的类名 所属文件名\n效果如下图：\n1545882158050\n 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到#### 4.6.4 继承中构造和析构顺序 子类继承父类后，当创建子类对象，也会调用父类的构造函数\n 问题：父类和子类的构造和析构顺序是谁先谁后？\n示例：\nclass Base { public: Base() { cout \u0026lt;\u0026lt; \u0026#34;Base构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } ~Base() { cout \u0026lt;\u0026lt; \u0026#34;Base析构函数!\u0026#34; \u0026lt;\u0026lt; endl; } }; class Son : public Base { public: Son() { cout \u0026lt;\u0026lt; \u0026#34;Son构造函数!\u0026#34; \u0026lt;\u0026lt; endl; } ~Son() { cout \u0026lt;\u0026lt; \u0026#34;Son析构函数!\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { //继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 \tSon s; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```\u0026gt; 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反#### 4.6.5 继承同名成员处理方式 问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？ * 访问子类同名成员 直接访问即可 * 访问父类同名成员 需要加作用域 *示例：* ​```C++ class Base { public: Base() { m_A = 100; } void func() { cout \u0026lt;\u0026lt; \u0026#34;Base - func()调用\u0026#34; \u0026lt;\u0026lt; endl; } void func(int a) { cout \u0026lt;\u0026lt; \u0026#34;Base - func(int a)调用\u0026#34; \u0026lt;\u0026lt; endl; } public: int m_A; }; class Son : public Base { public: Son() { m_A = 200; } //当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 \t//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 \tvoid func() { cout \u0026lt;\u0026lt; \u0026#34;Son - func()调用\u0026#34; \u0026lt;\u0026lt; endl; } public: int m_A; }; void test01() { Son s; cout \u0026lt;\u0026lt; \u0026#34;Son下的m_A = \u0026#34; \u0026lt;\u0026lt; s.m_A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Base下的m_A = \u0026#34; \u0026lt;\u0026lt; s.Base::m_A \u0026lt;\u0026lt; endl; s.func(); s.Base::func(); s.Base::func(10); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return EXIT_SUCCESS; } 总结：\n 子类对象可以直接访问到子类中同名成员 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数  4.6.6 继承同名静态成员处理方式 问题：继承中同名的静态成员在子类对象上如何进行访问？\n静态成员和非静态成员出现同名，处理方式一致\n 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域  示例：\nclass Base { public: static void func() { cout \u0026lt;\u0026lt; \u0026#34;Base - static void func()\u0026#34; \u0026lt;\u0026lt; endl; } static void func(int a) { cout \u0026lt;\u0026lt; \u0026#34;Base - static void func(int a)\u0026#34; \u0026lt;\u0026lt; endl; } static int m_A; }; int Base::m_A = 100; class Son : public Base { public: static void func() { cout \u0026lt;\u0026lt; \u0026#34;Son - static void func()\u0026#34; \u0026lt;\u0026lt; endl; } static int m_A; }; int Son::m_A = 200; //同名成员属性 void test01() { //通过对象访问 \tcout \u0026lt;\u0026lt; \u0026#34;通过对象访问： \u0026#34; \u0026lt;\u0026lt; endl; Son s; cout \u0026lt;\u0026lt; \u0026#34;Son 下 m_A = \u0026#34; \u0026lt;\u0026lt; s.m_A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Base 下 m_A = \u0026#34; \u0026lt;\u0026lt; s.Base::m_A \u0026lt;\u0026lt; endl; //通过类名访问 \tcout \u0026lt;\u0026lt; \u0026#34;通过类名访问： \u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Son 下 m_A = \u0026#34; \u0026lt;\u0026lt; Son::m_A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Base 下 m_A = \u0026#34; \u0026lt;\u0026lt; Son::Base::m_A \u0026lt;\u0026lt; endl; } //同名成员函数 void test02() { //通过对象访问 \tcout \u0026lt;\u0026lt; \u0026#34;通过对象访问： \u0026#34; \u0026lt;\u0026lt; endl; Son s; s.func(); s.Base::func(); cout \u0026lt;\u0026lt; \u0026#34;通过类名访问： \u0026#34; \u0026lt;\u0026lt; endl; Son::func(); Son::Base::func(); //出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问 \tSon::Base::func(100); } int main() { //test01(); \ttest02(); system(\u0026#34;pause\u0026#34;); return 0; } ​```\u0026gt; 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）#### 4.6.7 多继承语法 C++允许*一个类继承多个类* 语法：` class 子类 ：继承方式 父类1 ， 继承方式 父类2...` 多继承可能会引发父类中有同名成员出现，需要加作用域区分 *C++实际开发中不建议用多继承* *示例：* ​```C++ class Base1 { public: Base1() { m_A = 100; } public: int m_A; }; class Base2 { public: Base2() { m_A = 200; //开始是m_B 不会出问题，但是改为mA就会出现不明确 \t} public: int m_A; }; //语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 { public: Son() { m_C = 300; m_D = 400; } public: int m_C; int m_D; }; //多继承容易产生成员同名的情况 //通过使用类名作用域可以区分调用哪一个基类的成员 void test01() { Son s; cout \u0026lt;\u0026lt; \u0026#34;sizeof Son = \u0026#34; \u0026lt;\u0026lt; sizeof(s) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s.Base1::m_A \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s.Base2::m_A \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```\u0026gt; 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域#### 4.6.8 菱形继承 *菱形继承概念：* 两个派生类继承同一个基类 又有某个类同时继承者两个派生类 这种继承被称为菱形继承，或者钻石继承 *典型的菱形继承案例：* IMG_256 *菱形继承问题：* 1. ``` 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。   草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。\n示例：\nclass Animal { public: int m_Age; }; //继承前加virtual关键字后，变为虚继承 //此时公共的父类Animal称为虚基类 class Sheep : virtual public Animal {}; class Tuo : virtual public Animal {}; class SheepTuo : public Sheep, public Tuo {}; void test01() { SheepTuo st; st.Sheep::m_Age = 100; st.Tuo::m_Age = 200; cout \u0026lt;\u0026lt; \u0026#34;st.Sheep::m_Age = \u0026#34; \u0026lt;\u0026lt; st.Sheep::m_Age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;st.Tuo::m_Age = \u0026#34; \u0026lt;\u0026lt; st.Tuo::m_Age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;st.m_Age = \u0026#34; \u0026lt;\u0026lt; st.m_Age \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题  4.7 多态 4.7.1 多态的基本概念 多态是C++面向对象三大特性之一\n多态分为两类\n 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态  静态多态和动态多态区别：\n 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址  下面通过案例进行讲解多态\nclass Animal { public: //Speak函数就是虚函数 \t//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 \tvirtual void speak() { cout \u0026lt;\u0026lt; \u0026#34;动物在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; class Cat :public Animal { public: void speak() { cout \u0026lt;\u0026lt; \u0026#34;小猫在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; class Dog :public Animal { public: void speak() { cout \u0026lt;\u0026lt; \u0026#34;小狗在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; //我们希望传入什么对象，那么就调用什么对象的函数 //如果函数地址在编译阶段就能确定，那么静态联编 //如果函数地址在运行阶段才能确定，就是动态联编  void DoSpeak(Animal \u0026amp; animal) { animal.speak(); } // //多态满足条件： //1、有继承关系 //2、子类重写父类中的虚函数 //多态使用： //父类指针或引用指向子类对象  void test01() { Cat cat; DoSpeak(cat); Dog dog; DoSpeak(dog); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n多态满足条件\n 有继承关系 子类重写父类中的虚函数  多态使用条件\n 父类指针或引用指向子类对象  重写：函数返回值类型 函数名 参数列表 完全一致称为重写\n4.7.2 多态案例一-计算器类 案例描述：\n分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类\n多态的优点：\n 代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护  示例：\n//普通实现 class Calculator { public: int getResult(string oper) { if (oper == \u0026#34;+\u0026#34;) { return m_Num1 + m_Num2; } else if (oper == \u0026#34;-\u0026#34;) { return m_Num1 - m_Num2; } else if (oper == \u0026#34;*\u0026#34;) { return m_Num1 * m_Num2; } //如果要提供新的运算，需要修改源码 \t} public: int m_Num1; int m_Num2; }; void test01() { //普通实现测试 \tCalculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout \u0026lt;\u0026lt; c.m_Num1 \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; c.m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; c.getResult(\u0026#34;+\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c.m_Num1 \u0026lt;\u0026lt; \u0026#34; - \u0026#34; \u0026lt;\u0026lt; c.m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; c.getResult(\u0026#34;-\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c.m_Num1 \u0026lt;\u0026lt; \u0026#34; * \u0026#34; \u0026lt;\u0026lt; c.m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; c.getResult(\u0026#34;*\u0026#34;) \u0026lt;\u0026lt; endl; } //多态实现 //抽象计算器类 //多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护 class AbstractCalculator { public : virtual int getResult() { return 0; } int m_Num1; int m_Num2; }; //加法计算器 class AddCalculator :public AbstractCalculator { public: int getResult() { return m_Num1 + m_Num2; } }; //减法计算器 class SubCalculator :public AbstractCalculator { public: int getResult() { return m_Num1 - m_Num2; } }; //乘法计算器 class MulCalculator :public AbstractCalculator { public: int getResult() { return m_Num1 * m_Num2; } }; void test02() { //创建加法计算器 \tAbstractCalculator *abc = new AddCalculator; abc-\u0026gt;m_Num1 = 10; abc-\u0026gt;m_Num2 = 10; cout \u0026lt;\u0026lt; abc-\u0026gt;m_Num1 \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete abc; //用完了记得销毁  //创建减法计算器 \tabc = new SubCalculator; abc-\u0026gt;m_Num1 = 10; abc-\u0026gt;m_Num2 = 10; cout \u0026lt;\u0026lt; abc-\u0026gt;m_Num1 \u0026lt;\u0026lt; \u0026#34; - \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete abc; //创建乘法计算器 \tabc = new MulCalculator; abc-\u0026gt;m_Num1 = 10; abc-\u0026gt;m_Num2 = 10; cout \u0026lt;\u0026lt; abc-\u0026gt;m_Num1 \u0026lt;\u0026lt; \u0026#34; * \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;m_Num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; abc-\u0026gt;getResult() \u0026lt;\u0026lt; endl; delete abc; } int main() { //test01();  test02(); system(\u0026#34;pause\u0026#34;); return 0; } ​```\u0026gt; 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多#### 4.7.3 纯虚函数和抽象类 在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为*纯虚函数* 纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;` 当类中有了纯虚函数，这个类也称为==抽象类== *抽象类特点*： * 无法实例化对象 * 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 *示例：* ​```C++ class Base { public: //纯虚函数 \t//类中只要有一个纯虚函数就称为抽象类 \t//抽象类无法实例化对象 \t//子类必须重写父类中的纯虚函数，否则也属于抽象类 \tvirtual void func() = 0; }; class Son :public Base { public: virtual void func() { cout \u0026lt;\u0026lt; \u0026#34;func调用\u0026#34; \u0026lt;\u0026lt; endl; }; }; void test01() { Base * base = NULL; //base = new Base; // 错误，抽象类无法实例化对象 \tbase = new Son; base-\u0026gt;func(); delete base;//记得销毁 } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.7.4 多态案例二-制作饮品 *案例描述：* 制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶 1545985945198 *示例：* ​```C++ //抽象制作饮品 class AbstractDrinking { public: //烧水 \tvirtual void Boil() = 0; //冲泡 \tvirtual void Brew() = 0; //倒入杯中 \tvirtual void PourInCup() = 0; //加入辅料 \tvirtual void PutSomething() = 0; //规定流程 \tvoid MakeDrink() { Boil(); Brew(); PourInCup(); PutSomething(); } }; //制作咖啡 class Coffee : public AbstractDrinking { public: //烧水 \tvirtual void Boil() { cout \u0026lt;\u0026lt; \u0026#34;煮农夫山泉!\u0026#34; \u0026lt;\u0026lt; endl; } //冲泡 \tvirtual void Brew() { cout \u0026lt;\u0026lt; \u0026#34;冲泡咖啡!\u0026#34; \u0026lt;\u0026lt; endl; } //倒入杯中 \tvirtual void PourInCup() { cout \u0026lt;\u0026lt; \u0026#34;将咖啡倒入杯中!\u0026#34; \u0026lt;\u0026lt; endl; } //加入辅料 \tvirtual void PutSomething() { cout \u0026lt;\u0026lt; \u0026#34;加入牛奶!\u0026#34; \u0026lt;\u0026lt; endl; } }; //制作茶水 class Tea : public AbstractDrinking { public: //烧水 \tvirtual void Boil() { cout \u0026lt;\u0026lt; \u0026#34;煮自来水!\u0026#34; \u0026lt;\u0026lt; endl; } //冲泡 \tvirtual void Brew() { cout \u0026lt;\u0026lt; \u0026#34;冲泡茶叶!\u0026#34; \u0026lt;\u0026lt; endl; } //倒入杯中 \tvirtual void PourInCup() { cout \u0026lt;\u0026lt; \u0026#34;将茶水倒入杯中!\u0026#34; \u0026lt;\u0026lt; endl; } //加入辅料 \tvirtual void PutSomething() { cout \u0026lt;\u0026lt; \u0026#34;加入枸杞!\u0026#34; \u0026lt;\u0026lt; endl; } }; //业务函数 void DoWork(AbstractDrinking* drink) { drink-\u0026gt;MakeDrink(); delete drink; } void test01() { DoWork(new Coffee); cout \u0026lt;\u0026lt; \u0026#34;--------------\u0026#34; \u0026lt;\u0026lt; endl; DoWork(new Tea); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```#### 4.7.5 虚析构和纯虚析构 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为*虚析构*或者*纯虚析构* 虚析构和纯虚析构共性： * 可以解决父类指针释放子类对象 * 都需要有具体的函数实现 虚析构和纯虚析构区别： * 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法： `virtual ~类名(){}` 纯虚析构语法： ` virtual ~类名() = 0;` `类名::~类名(){}` *示例：* ​```C++ class Animal { public: Animal() { cout \u0026lt;\u0026lt; \u0026#34;Animal 构造函数调用！\u0026#34; \u0026lt;\u0026lt; endl; } virtual void Speak() = 0; //析构函数加上virtual关键字，变成虚析构函数 \t//virtual ~Animal() \t//{ \t//\tcout \u0026lt;\u0026lt; \u0026#34;Animal虚析构函数调用！\u0026#34; \u0026lt;\u0026lt; endl; \t//}  virtual ~Animal() = 0; }; Animal::~Animal() { cout \u0026lt;\u0026lt; \u0026#34;Animal 纯虚析构函数调用！\u0026#34; \u0026lt;\u0026lt; endl; } //和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。  class Cat : public Animal { public: Cat(string name) { cout \u0026lt;\u0026lt; \u0026#34;Cat构造函数调用！\u0026#34; \u0026lt;\u0026lt; endl; m_Name = new string(name); } virtual void Speak() { cout \u0026lt;\u0026lt; *m_Name \u0026lt;\u0026lt; \u0026#34;小猫在说话!\u0026#34; \u0026lt;\u0026lt; endl; } ~Cat() { cout \u0026lt;\u0026lt; \u0026#34;Cat析构函数调用!\u0026#34; \u0026lt;\u0026lt; endl; if (this-\u0026gt;m_Name != NULL) { delete m_Name; m_Name = NULL; } } public: string *m_Name; }; void test01() { Animal *animal = new Cat(\u0026#34;Tom\u0026#34;); animal-\u0026gt;Speak(); //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 \t//怎么解决？给基类增加一个虚析构函数 \t//虚析构函数就是用来解决通过父类指针释放子类对象 \tdelete animal; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 3. 拥有纯虚析构函数的类也属于抽象类  4.7.6 多态案例三-电脑组装 案例描述：\n电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）\n将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商\n创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口\n测试时组装三台不同的电脑进行工作\n示例：\n#include\u0026lt;iostream\u0026gt;using namespace std; //抽象CPU类 class CPU { public: //抽象的计算函数 \tvirtual void calculate() = 0; }; //抽象显卡类 class VideoCard { public: //抽象的显示函数 \tvirtual void display() = 0; }; //抽象内存条类 class Memory { public: //抽象的存储函数 \tvirtual void storage() = 0; }; //电脑类 class Computer { public: Computer(CPU * cpu, VideoCard * vc, Memory * mem) { m_cpu = cpu; m_vc = vc; m_mem = mem; } //提供工作的函数 \tvoid work() { //让零件工作起来，调用接口 \tm_cpu-\u0026gt;calculate(); m_vc-\u0026gt;display(); m_mem-\u0026gt;storage(); } //提供析构函数 释放3个电脑零件 \t~Computer() { //释放CPU零件 \tif (m_cpu != NULL) { delete m_cpu; m_cpu = NULL; } //释放显卡零件 \tif (m_vc != NULL) { delete m_vc; m_vc = NULL; } //释放内存条零件 \tif (m_mem != NULL) { delete m_mem; m_mem = NULL; } } private: CPU * m_cpu; //CPU的零件指针 \tVideoCard * m_vc; //显卡零件指针 \tMemory * m_mem; //内存条零件指针 }; //具体厂商 //Intel厂商 class IntelCPU :public CPU { public: virtual void calculate() { cout \u0026lt;\u0026lt; \u0026#34;Intel的CPU开始计算了！\u0026#34; \u0026lt;\u0026lt; endl; } }; class IntelVideoCard :public VideoCard { public: virtual void display() { cout \u0026lt;\u0026lt; \u0026#34;Intel的显卡开始显示了！\u0026#34; \u0026lt;\u0026lt; endl; } }; class IntelMemory :public Memory { public: virtual void storage() { cout \u0026lt;\u0026lt; \u0026#34;Intel的内存条开始存储了！\u0026#34; \u0026lt;\u0026lt; endl; } }; //Lenovo厂商 class LenovoCPU :public CPU { public: virtual void calculate() { cout \u0026lt;\u0026lt; \u0026#34;Lenovo的CPU开始计算了！\u0026#34; \u0026lt;\u0026lt; endl; } }; class LenovoVideoCard :public VideoCard { public: virtual void display() { cout \u0026lt;\u0026lt; \u0026#34;Lenovo的显卡开始显示了！\u0026#34; \u0026lt;\u0026lt; endl; } }; class LenovoMemory :public Memory { public: virtual void storage() { cout \u0026lt;\u0026lt; \u0026#34;Lenovo的内存条开始存储了！\u0026#34; \u0026lt;\u0026lt; endl; } }; void test01() { //第一台电脑零件 \tCPU * intelCpu = new IntelCPU; VideoCard * intelCard = new IntelVideoCard; Memory * intelMem = new IntelMemory; cout \u0026lt;\u0026lt; \u0026#34;第一台电脑开始工作：\u0026#34; \u0026lt;\u0026lt; endl; //创建第一台电脑 \tComputer * computer1 = new Computer(intelCpu, intelCard, intelMem); computer1-\u0026gt;work(); delete computer1; cout \u0026lt;\u0026lt; \u0026#34;-----------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;第二台电脑开始工作：\u0026#34; \u0026lt;\u0026lt; endl; //第二台电脑组装 \tComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);; computer2-\u0026gt;work(); delete computer2; cout \u0026lt;\u0026lt; \u0026#34;-----------------------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;第三台电脑开始工作：\u0026#34; \u0026lt;\u0026lt; endl; //第三台电脑组装 \tComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);; computer3-\u0026gt;work(); delete computer3; } ​```## 5 文件操作 程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过*文件可以将数据持久化* C++中对文件操作需要包含头文件 ==\u0026lt; fstream \u0026gt;== 文件类型分为两种： 1. *文本文件* - 文件以文本的*ASCII码*形式存储在计算机中 2. *二进制文件* - 文件以文本的*二进制*形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类: 1. ofstream：写操作 2. ifstream： 读操作 3. fstream ： 读写操作 ### 5.1文本文件 #### 5.1.1写文件 写文件步骤如下： 1. 包含头文件 #include \u0026lt;fstream\u0026gt; 2. 创建流对象 ofstream ofs; 3. 打开文件 ofs.open(\u0026#34;文件路径\u0026#34;,打开方式); 4. 写数据 ofs \u0026lt;\u0026lt; \u0026#34;写入的数据\u0026#34;; 5. 关闭文件 ofs.close(); 文件打开方式： | 打开方式 | 解释 | | ----------- | -------------------------- | | ios::in | 为读文件而打开文件 | | ios::out | 为写文件而打开文件 | | ios::ate | 初始位置：文件尾 | | ios::app | 追加方式写文件 | | ios::trunc | 如果文件存在先删除，再创建 | | ios::binary | 二进制方式 | *注意：* 文件打开方式可以配合使用，利用|操作符 **例如：**用二进制方式写文件 `ios::binary | ios:: out` *示例：* ​```C++ #include \u0026lt;fstream\u0026gt; void test01() { ofstream ofs; ofs.open(\u0026#34;test.txt\u0026#34;, ios::out); ofs \u0026lt;\u0026lt; \u0026#34;姓名：张三\u0026#34; \u0026lt;\u0026lt; endl; ofs \u0026lt;\u0026lt; \u0026#34;性别：男\u0026#34; \u0026lt;\u0026lt; endl; ofs \u0026lt;\u0026lt; \u0026#34;年龄：18\u0026#34; \u0026lt;\u0026lt; endl; ofs.close(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n 文件操作必须包含头文件 fstream 读文件可以利用 ofstream ，或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用\u0026laquo;可以向文件中写数据 操作完毕，要关闭文件  5.1.2读文件 读文件与写文件步骤相似，但是读取方式相对于比较多\n读文件步骤如下： 1. 包含头文件\n#include   创建流对象\nifstream ifs;\n  打开文件并判断文件是否打开成功\nifs.open(\u0026ldquo;文件路径\u0026rdquo;,打开方式);\n  读数据\n四种方式读取\n  关闭文件\nifs.close();\n示例：\n#include \u0026lt;fstream\u0026gt;#include \u0026lt;string\u0026gt;void test01() { ifstream ifs; ifs.open(\u0026#34;test.txt\u0026#34;, ios::in); if (!ifs.is_open()) { cout \u0026lt;\u0026lt; \u0026#34;文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; return; } //第一种方式 \t//char buf[1024] = { 0 }; \t//while (ifs \u0026gt;\u0026gt; buf) \t//{ \t//\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; \t//}  //第二种 \t//char buf[1024] = { 0 }; \t//while (ifs.getline(buf,sizeof(buf))) \t//{ \t//\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; \t//}  //第三种 \t//string buf; \t//while (getline(ifs, buf)) \t//{ \t//\tcout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; \t//}  char c; while ((c = ifs.get()) != EOF) { cout \u0026lt;\u0026lt; c; } ifs.close(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n 读文件可以利用 ifstream ，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件  5.2 二进制文件 以二进制的方式对文件进行读写操作\n打开方式要指定为 ==ios::binary==\n5.2.1 写文件 二进制方式写文件主要利用流对象调用成员函数write\n函数原型 ：ostream\u0026amp; write(const char * buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n#include \u0026lt;fstream\u0026gt;#include \u0026lt;string\u0026gt; class Person { public: char m_Name[64]; int m_Age; }; //二进制文件 写文件 void test01() { //1、包含头文件  //2、创建输出流对象 \tofstream ofs(\u0026#34;person.txt\u0026#34;, ios::out | ios::binary); //3、打开文件 \t//ofs.open(\u0026#34;person.txt\u0026#34;, ios::out | ios::binary);  Person p = {\u0026#34;张三\u0026#34; , 18}; //4、写文件 \tofs.write((const char *)\u0026amp;p, sizeof(p)); //5、关闭文件 \tofs.close(); } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } 总结：\n 文件输出流对象 可以通过write函数，以二进制方式写数据  5.2.2 读文件 二进制方式读文件主要利用流对象调用成员函数read\n函数原型：istream\u0026amp; read(char *buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n#include \u0026lt;fstream\u0026gt;#include \u0026lt;string\u0026gt; class Person { public: char m_Name[64]; int m_Age; }; void test01() { ifstream ifs(\u0026#34;person.txt\u0026#34;, ios::in | ios::binary); if (!ifs.is_open()) { cout \u0026lt;\u0026lt; \u0026#34;文件打开失败\u0026#34; \u0026lt;\u0026lt; endl; } Person p; ifs.read((char *)\u0026amp;p, sizeof(p)); cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; p.m_Name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; p.m_Age \u0026lt;\u0026lt; endl; } int main() { test01(); system(\u0026#34;pause\u0026#34;); return 0; } ​```* 文件输入流对象 可以通过read函数，以二进制方式读数据 ","permalink":"https://github.com/FreanJa/freanja.github.io/post/blog/","summary":"本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。\n1 内存分区模型 C++程序在执行时，将内存大方向划分为4个区域\n 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收  内存四区意义：\n不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n1.1 程序运行前 在程序编译后，生成了exe可执行程序，*未执行该程序前*分为两个区域 *代码区：* 存放 CPU 执行的机器指令 代码区是*共享*的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 代码区是*只读*的，使其只读的原因是防止程序意外地修改了它的指令 *全局区：* 全局变量和静态变量存放在此. 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ==该区域的数据在程序结束后由操作系统释放==.  示例：\n//全局变量 int g_a = 10; int g_b = 10; //全局常量 const int c_g_a = 10; const int c_g_b = 10; int main() { //局部变量 \tint a = 10; int b = 10; //打印地址 \tcout \u0026lt;\u0026lt; \u0026#34;局部变量a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;局部变量b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局变量g_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;g_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局变量g_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;g_b \u0026lt;\u0026lt; endl; //静态变量 \tstatic int s_a = 10; static int s_b = 10; cout \u0026lt;\u0026lt; \u0026#34;静态变量s_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;s_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;静态变量s_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;s_b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;字符串常量地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;\u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;字符串常量地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;\u0026#34;hello world1\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局常量c_g_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_g_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;全局常量c_g_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_g_b \u0026lt;\u0026lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout \u0026lt;\u0026lt; \u0026#34;局部常量c_l_a地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_l_a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;局部常量c_l_b地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;c_l_b \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 打印结果：","title":"C++核心编程"},{"content":"Chap 1 Introduction   What is the difference between a host and an end system? List several different types of end systems. Is a Web server an end system?  ANS There is no difference. Throughout this text, the words “host” and “end system” are used interchangeably. End systems include PCs, workstations, Web servers, mail servers, PDAs, Internet-connected game consoles, etc.\n 没有区别。在本文中，“主机”和“终端系统”这两个词是互换使用的。 终端系统包括pc机、工作站、Web服务器、邮件服务器、pda、联网游戏机等。 Web服务器也是终端系统   Describe the protocol that might be used by two people having a telephonic conversation to initiate and end the conversation.  ANS Based on the human protocol, in order to generate a telephonic conversation. When a caller initiates a call, and after the callee accepts the call, the caller commences the communication by using specific messages (e.g., Allo (a message transmitting to, and received by the callee)), and after receiving feedback from the callee (e.g., Hello (transmitting an implicit message to the caller)). Then, they both keep the communication on based specific sent messages (transmitting messages from caller to callee and vice versa), and specific received response messages (transmitting a replay to caller or callee). After finishing the talk, one of the involved parts could end up the call by using some key works (e.g., I have to go now, goodbye) and they both end up the call by hanging up the phones.\n发起方： Hello；接收方回复\t\u0026ndash;—\u0026gt; 开始对话 双方交换信息 某一方提出结束，另一方接收到这个信息\t—-\u0026gt; 结束通话\n Why are standards important for protocols?  ANS Standards are important for protocols so that people can create networking systems and products that interoperate. 标准对于协议很重要，这样人们就可以创建能够互操作的网络系统和产品。 （有统一的标准，就可以协同工作）\n Consider sending a packet from a source host to a destination host over a fixed route. List the delay components in the end-to-end delay. Which of these delays are constant and which are variable?  ANS The delay components are processing delays, transmission delays, propagation delays, and queuing delays. All of these delays are fixed, except for the queuing delays, which are variable. 延迟组件是处理延迟、传输延迟、传播延迟和排队延迟。所有这些延迟都是固定的，除了 ~排队延迟是可变~ 的。\n A user can directly connect to a server through either long-range wireless or a twisted-pair cable for transmitting a 1500-bytes file. The transmission rates of the wireless and wired media are 2 and 100 Mbps, respectively. Assume that the propagation speed in air is 3 * 108 m/s, while the speed in the twisted pair is 2 * 108 m/s. If the user is located 1 km away from the server, what is the nodal delay when using each of the two technologies?  ANS transmission delay + propagation delay dTrans = L/R\tdProp = d/s\n Suppose Host A wants to send a large file to Host B. The path from Host A to Host B has three links, of rates R1 = 500 kbps, R2 = 2 Mbps, and R3 = 1 Mbps.  Assuming no other traffic in the network, what is the throughput for the file transfer? Suppose the file is 4 million bytes. Dividing the file size by the through- put, roughly how long will it take to transfer the file to Host B? Repeat (a) and (b), but now with R2 reduced to 100 kbps.    ANS * 500 kbps （ determined by minimum rata ) * 64 seconds ( 4 * 106 * 8 / 0.5 * 106 ) * 100kbps; 320 seconds ( choose 100kbps )\n Suppose end system A wants to send a large file to end system B. At a very high level, describe how end system A creates packets from the file. When one of these packets arrives to a router, what information in the packet does the router use to determine the link onto which the packet is forwarded? Why is packet switching in the Internet analogous to driving from one city to another and asking directions along the way? 假设端系统A想向端系统B发送一个大文件。  在一个非常高的级别上，描述端系统A如何从该文件创建数据包。 当其中一个数据包到达路由器时，路由器使用数据包中的什么信息来确定数据包所转发到的链路? 为什么因特网上的分组交换类似于开车从一个城市到另一个城市，并在途中问路?    ANS End system A breaks the large file into chunks. It adds header to each chunk, thereby generating multiple packets from the file. The header in each packet includes the IP address of the destination (end system B). The packet switch uses the destination IP address in the packet to determine the outgoing link. Asking which road to take is analogous to a packet asking which outgoing link it should be forwarded on, given the packet’s destination address. 终端系统A将大文件分成若干块。它向每个块添加头，从而从文件生成多个包。每个包的报头包括目的(端系统B)的IP地址。 包交换机根据包中的目的IP地址来确定出路。 询问要走哪条路类似于信息包在给定数据包的目的地址的情况下询问它应该沿着哪条输出链路转发。\n If two end-systems are connected through multiple routers and the datalink level between them ensures reliable data delivery, is a transport protocol offering reliable data delivery between these two end-systems necessary? Why? 如果两个终端系统通过多个路由器连接，并且它们之间的数据链路层确保了可靠的数据传递，那么在这两个终端系统之间提供可靠的数据传递的传输协议是必要的吗?为什么?  ANS A reliable data link protocol can recover from errors affecting transmissions on individual links. However, there are more sources of losses in an interconnection network formed by multiple routers. For instance, messages can be dropped by a router whose buffer is completely filled with packets. Moreover, a router may malfunction or break, thus destroying all buffered messages. Thus, it makes more sense to use a transport protocol for reliable data delivery in the considered scenario. 一个可靠的数据链路协议可以从影响单个链路传输的错误中恢复。 然而，在由多个路由器组成的互连网络中，有更多的损耗来源。例如，报文可以被路由器的缓冲区完全填满。此外，路由器可能发生故障或中断，从而破坏所有缓冲的消息。因此，在考虑的场景中使用传输协议进行可靠的数据传递更有意义。\n What are the five layers in the Internet protocol stack? What are the principal responsibilities of each of these layers?  ANS * Application layer: Implement a specific network application through the interaction between application processes 通过应用进程间的交互来完成特定网络应用 * Transport layer: Provides a common data transfer service for communication between processes in two hosts 为两个主机中进程之间的通信提供通用的数据传输服务 * Network layer:Communication services are provided by different hosts on a packet switched network 分组交换网上不同主机提供通信服务 * Link layer:On-link transmission between two adjacent nodes 两个相邻节点间的链路上传送问题 * Physical layer:Transmits bitstreams transparently 透明地传送比特流\n What do encapsulation and de-encapsulation mean? Why are they needed in a layered protocol stack? 封装和反封装是什么意思?为什么在分层协议栈中需要它们?  ANS Encapsulation is the process of passing a packet from a higher layer to a lower layer. In the simplest case, it simply appends additional information (i.e., a header) to the source packet. In more complicated scenarios, the original packet can be split into multiple packets, each carrying its own header. 封装是将一个数据包从较高的层传递到较低的层的过程。在最简单的情况下，它只是将附加信息(例如，一个头)附加到源包。在更复杂的情况下，原始数据包可以被拆分为多个数据包，每个数据包携带自己的报头。 Decapsulation is the opposite process of encapsulation. It extracts the header from a source packet from a lower layer and passes the payload to the higher layer. If lower layer packets are part of a sequence, the corresponding payloads are put together before they are passed to the higher layer. 解封装是封装的相反过程。它从较低一层的源包中提取报头，并将有效负载传递给较高一层。如果较低层的数据包是序列的一部分，相应的有效负载在传递到较高层之前被放在一起。 Each protocol in a layer of a protocol stack relies on the services of the lower layers but not on their information. Thus, the information a protocol needs to process a packet should entirely be contained in the header of that protocol. Encapsulation and decapsulation are flexible mechanisms to allow each protocol to operate independently from others while being able to interface with each other. 协议栈一层中的每个协议依赖于较低层的服务，而不是它们的信息。因此,协议需要处理数据包的信息应该完全包含在该协议的报头中。封装和解封装是一种灵活的机制，允许每个协议独立地操作，同时能够相互接口。\n Which layers in the Internet protocol stack does a router process? Which layers does a link-layer switch process? Which layers does a host process? 路由器处理因特网协议栈的哪一层?链路层交换处理哪些层?宿主进程要处理哪些层?  ANS Routers process network, link and physical layers (layers 1 through 3). Link layer switches process link and physical layers (layers 1 through2). Hosts process all five layers.\n Chap 2 Application Layer   A user requests a Web page that consists of some text and three images. For this page, the client will send one request message and receive four response messages. 用户请求一个由一些文本和三个图像组成的Web页面。对于这个页面，客户机将发送一条请求消息，并接收四条响应消息。  False request - response 需一一对应\n Two distinct Web pages (for example, www.mit.edu/research.html and www.mit.edu/students.html) can be sent over the same persistent connection. 两个不同的Web页面(例如 www.mit.edu/research.html和www.mit.edu/students.html)可以通过同一个持久连接发送。  True 同一个域名对应同一台服务器，已经建立了TCP连接，可以传输多个object\n With non-persistent connections between browser and origin server, it is possible for a single TCP segment to carry two distinct HTTP request messages. 在浏览器和源服务器之间的非持久连接中，单个TCP段可以携带两个不同的HTTP请求消息。  False 非持续连接中，一个object — 一个TCP连接\n The Date: header in the HTTP response message indicates when the object in the response was last modified. HTTP响应消息中的Date: 标头表示响应中的对象最后一次修改的时间。  False Last modified Date: 报文创建时间\n HTTP response messages never have an empty message body. HTTP响应消息不会有空消息体。  False 204 No Content\n The Last-Modified: header in the HTTP response message indicate when the object in the response was last modified  True\n With persistent connections between browser and origin server, it is possible for a single TCP segment (or packet) to carry two distinct HTTP request messages?  True\n List five non-proprietary Internet applications and the application-layer protocols that they use.  The Web: HTTP; file transfer: FTP; remote login: Telnet; e-mail: SMTP; BitTorrent file sharing: BitTorrent protocol\n What is the difference between network architecture and application architecture?  Network architecture refers to the organization of the communication process into layers (e.g., the five-layer Internet architecture). 网络体系结构是指将通信过程组织成层(如五层Internet体系结构)。 Application architecture, on the other hand, is designed by an application developer and dictates the broad structure of the application (e.g., client-server or P2P). 应用程序架构是由应用程序开发人员设计的，它规定了应用程序的总体结构(例如，客户机-服务器或P2P)。\n For a communication session between a pair of processes, which process is the client and which is the server?  The process which initiates the communication is the client; the process that waits to be contacted is the server. 发起通信的过程是客户端;等待联系的进程是服务器。\n Why are the terms client and server still used in peer-to-peer applications?  In a P2P file-sharing application, the peer that is receiving a file is typically the client and the peer that is sending the file is typically the server. 在P2P文件共享应用程序中，接收文件的对等体通常是客户端，发送文件的对等体通常是服务器。\n What information is used by a process running on one host to identify a process running on another host?  The IP address of the destination host and the port number of the socket in the destination process. 目的主机的IP地址和目的进程中套接字的端口号。 destination host’s IP address \u0026amp; port number of the socket\n What is the role of HTTP in a network application? What other components are needed to complete a Web application?  Establish the connection between client and server for data transmission 建立客户端和服务器的连接，进行数据传输\n Referring to Figure 2.4, we see that none of the applications listed in Figure 2.4 requires both no data loss and timing. Can you conceive of an application that requires no data loss and that is also highly time-sensitive?  One such example is remote word processing, for example, with Google docs. However, because Google docs runs over the Internet (using TCP), timing guarantees are not provided.\n List the four broad classes of services that a transport protocol can provide. For each of the service classes, indicate if either UDP or TCP (or both) provides such a service.  a) Reliable data transfer TCP provides a reliable byte-stream between client and server but UDP does not. b) A guarantee that a certain value for throughput will be maintained Neither c) A guarantee that data will be delivered within a specified amount of time Neither d) Confidentiality (via encryption) Neither\n1.可靠的数据传输；2.保持一定吞吐量；3.保证一定时间内交付；4.机密性\n What is meant by a handshaking protocol?  A protocol uses handshaking if the two communicating entities first exchange control packets before sending data to each other. SMTP uses handshaking at the application layer whereas HTTP does not. 如果两个通信实体在互相发送数据之前先交换控制数据包，那么协议使用握手。SMTP在应用层使用握手，而HTTP不使用。\n What does a stateless protocol mean? Is IMAP stateless? What about SMTP?  IMAP无状态 SMTP有状态\n How can websites keep track of users? Do they always need to use cookies? 网站如何跟踪用户?他们总是需要使用cookie吗?  IP地址； HTTP Referrer； Cookies；User agent\n Describe how Web caching can reduce the delay in receiving a requested object. Will Web caching reduce the delay for all objects requested by a user or for only some of the objects? Why? 描述Web缓存如何减少接收请求对象时的延迟。Web缓存是否减少了用户请求的所有对象的延迟，还是只减少了部分对象的延迟?为什么?  Web caching can bring the desired content “closer” to the user, possibly to the same LAN to which the user’s host is connected. Web caching can reduce the delay for all objects, even objects that are not cached, since caching reduces the traffic on links. Web缓存可以使所需内容“更接近”用户，可能与用户的主机所连接的同一局域网。Web缓存可以减少所有对象的延迟，甚至是未缓存的对象，因为缓存减少了链接上的流量。\n Telnet into a Web server and send a multiline request message. Include in the request message the If-modified-since: header line to force a response message with the 304 Not Modified status code. Telnet到Web服务器并发送多行请求消息。在请求消息中包含If-modified-since:标题行，以强制使用304 Not Modified状态码的响应消息。   Are there any constraints on the format of the HTTP body? What about the email message body sent with SMTP? How can arbitrary data be transmitted over SMTP?  对HTTP正文格式的约束 是的，在HTTP正文的格式上存在协议约束。协议约束用于防止缓冲区溢出之类的攻击。缓冲区溢出可能发生在web应用程序和服务器中，这些应用程序和服务器没有将HTTP协议的元素限制在可接受的长度内，或者错误地处理了格式不正确的请求。这样的错误会导致安全性问题\n Web Page A Web page(also called a document) consists of objects. Web页面(也称为文档)由对象组成。\nObject An object is simply a file—such as an HTML file, a JPEG image, a Java applet, or a video clip—that is addressable by a single URL. 对象只是一个文件，例如HTML文件、JPEG图像、Java applet或视频剪辑，可以通过单个URL寻址。\nURL Uniform Resource Locator 统一资源定位器\nWeb browser / client Web servers / server HTTP HyperText Transfer Protocol 超文本传输协议\nRequest message Response message TCP HTTP uses TCP as its underlying transport protocol (rather than running on top of UDP). 传输控制协议 Transmission Control Protocol 是一种面向连接的、可靠的、基于字节流的传输层通信协议\nStateless protocol Because an HTTP server maintains no information about the clients, HTTP is said to be a stateless protocol. 因为HTTP服务器不维护关于客户端的信息，所以HTTP被称为无状态协议。\nPersistent connection all of the requests and their corresponding responses be sent over the sameTCP connection 通过相同的TCP连接发送所有的请求及其相应的响应\nNon-Persistent connection each request/response pair be sent over a separateTCP connection 通过单独的TCP连接发送每个请求/响应对\nround trip time (RTT) which is the time it takes for a small packet to travel from client to server and then back to the client. 从请求到接收到文件的总时间\ndnodal = dproc + dqueue + dtrans + dprop packet-propagation delay (包传递 到下个节点 §d: length of physical link §s: propagation speed (~2x108 m/sec) dprop = d/s\npacket-queueing delay (包排队 packet-processing delay (包处理 packet-transmission delay (包传输 节点内 §L: packet length (bits) §R: link transmission rate (bps) dtrans = L/R\nChap 3   Host A is sending Host B a large file over a TCP connection. Assume Host B has no data to send Host A. Host B will not send acknowledgments to Host A because Host B cannot piggyback the acknowledgments on data.  False TCP是可靠传输 一定会有确认信息\n The size of the TCP rwnd never changes throughout the duration of the connection.  False rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]. rwnd表示的是接收窗口的大小, 这取决于接收方应用程序从缓存中读取数据的速率和发送方发送的速率, 是会变化的.\n Suppose Host A is sending Host B a large file over a TCP connection. The number of unacknowledged bytes that A sends cannot exceed the size of the receive buffer.  True\n Suppose Host A is sending a large file to Host B over a TCP connection. If the sequence number for a segment of this connection is m, then the sequence number for the subsequent segment will necessarily be m + 1. 如果这个连接的一个段的序列号是m，那么后续的段的序列号必然是m + 1。  False 序号是根据TCP数据的字节流决定的, 而不是建立在报文序列之上. 后继报文段的序号应该是m + n, 而n是最大报文段长度.\n The TCP segment has a field in its header for rwnd.  True\n Suppose that the last SampleRTT in a TCP connection is equal to 1 sec. The current value of TimeoutInterval for the connection will necessarily be ≥ 1 sec.  False EstimatedRTT = (1-a)EstimatedRTT +aSampleRTT TimeoutInterval = EstimatedRTT + 4*DevRTT\n Suppose Host A sends one segment with sequence number 38 and 4 bytes of data over a TCP connection to Host B. In this same segment the acknowledgment number is necessarily 42.  False acknowledgment number 是 A expecting from B\n Before sending a packet into a datagram network, the source must determine all of the links that packet will traverse between source and destination.  False\n How is a UDP socket fully identified? What about a TCP socket? What is the difference between the full identification of both sockets?   Describe why an application developer might choose to run an application over UDP rather than TCP.  An application developer may not want its application to use TCP’s congestion control, which can throttle the application’s sending rate at times of congestion. Often, designers of IP telephony and IP videoconference applications choose to run their applications over UDP because they want to avoid TCP’s congestion control. Also, some applications do not need the reliable data transfer provided by TCP. 应用程序开发人员可能不希望其应用程序使用TCP的拥塞控制，这可能会在拥塞时抑制应用程序的发送速率。通常，IP电话和IP视频会议应用程序的设计者选择在UDP上运行他们的应用程序，因为他们想避免TCP的拥塞控制。另外，有些应用程序不需要TCP提供的可靠数据传输。\n Why is it that voice and video traffic is often sent over TCP rather than UDP in today’s Internet? (Hint: The answer we are looking for has nothing to do with TCP’s congestion-control mechanism.)  Since most firewalls are configured to block UDP traffic, using TCP for video and voice traffic lets the traffic though the firewalls. 由于大多数防火墙配置为阻断UDP流量，因此使用TCP来处理视频和语音流量可以让流量通过防火墙。\n Is it possible for an application to enjoy reliable data transfer even when the application runs over UDP? If so, how?  Yes. The application developer can put reliable data transfer into the application layer protocol. This would require a significant amount of work and debugging, however. 是的。应用程序开发人员可以将可靠的数据传输放到应用层协议中。然而，这将需要大量的工作和调试。\n Suppose a process in Host C has a UDP socket with port number 6789. Suppose both Host A and Host B each send a UDP segment to Host C with destination port number 6789. Will both of these segments be directed to the same socket at Host C? If so, how will the process at Host C know that these two segments originated from two different hosts?  Yes, both segments will be directed to the same socket. For each received segment, at the socket interface, the operating system will provide the process with the IP addresses to determine the origins of the individual segments. 是的，两个段将被定向到同一个套接字。对于每个接收到的段，在套接字接口上，操作系统将向进程提供IP地址，以确定各个段的起源。\n Suppose that a Web server runs in Host C on port 80. Suppose this Web server uses persistent connections, and is currently receiving requests from two different Hosts, A and B. Are all of the requests being sent through the same socket at Host C? If they are being passed through different sockets, do both of the sockets have port 80? Discuss and explain.  For each persistent connection, the Web server creates a separate “connection socket”. Each connection socket is identified with a four-tuple: (source IP address, source port number, destination IP address, destination port number). When host C receives and IP datagram, it examines these four fields in the datagram/segment to determine to which socket it should pass the payload of the TCP segment. Thus, the requests from A and B pass through different sockets. The identifier for both of these sockets has 80 for the destination port; however, the identifiers for these sockets have different values for source IP addresses. Unlike UDP, when the transport layer passes a TCP segment’s payload to the application process, it does not specify the source IP address, as this is implicitly specified by the socket identifier. 对于每个持久连接，Web服务器创建一个单独的“连接套接字”。每个连接套接字用一个四元组(源IP地址、源端口号、目的IP地址、目的端口号)来标识。当主机C接收到IP数据报时，它检查数据报/段中的这四个字段，以确定应该将TCP段的有效负载传递给哪个套接字。因此，来自A和B的请求通过不同的套接字。这两个套接字的标识符的目的端口都是80;但是，这些套接字的标识符对于源IP地址有不同的值。与UDP不同，当传输层将TCP段的有效负载传递给应用程序进程时，它不指定源IP地址，因为这是由套接字标识符隐式指定的。\n Suppose Host A sends two TCP segments back to back to Host B over a TCP connection. The first segment has sequence number 90; the second has sequence number 110.  How much data is in the first segment? Suppose that the first segment is lost but the second segment arrives at B. In the acknowledgment that Host B sends to Host A, what will be the acknowledgment number?    a) Consider sequence numbers, First segment=90\tSecond segment=110 Data in the first segment= 110-90 =20 b) Consider the first segment is lost but the second segment arrives at B. In the acknowledgment that Host B sends to Host A, then the acknowledgment number will be first segment of sequence number, that is 90.\n Consider the Telnet example discussed in Section 3.5. A few seconds after the user types the letter ‘C,’ the user types the letter ‘R.’ After typing the letter ‘R,’ how many segments are sent, and what is put in the sequence number and acknowledgment fields of the segments?   当主机A发送数据= ' R \u0026lsquo;时，则以序列号= 43和确认号= 80的分段发送给主机B。 然后主机B发送数据= ' R ' (echoesback ' R \u0026lsquo;)，序列号= 80，确认号= 44的段作为收据。 然后，主机A通过发送序列号为44、确认号为81的分段以及任何其他数据(如果有的话)来确认收到回显的\u0026rsquo; R \u0026lsquo;。\nPiggyback Note that the acknowledgment for client-to-server data is carried in a segment carrying server-to-client data; this acknowledgment is said to be piggybackedon the server-to-client data segment.\nAcknowledgement MSS The maximum amount of data that can be grabbed and placed in a segment is limited by the maximum segment size (MSS) 可以在一个段中抓取和放置的最大数据量受**最大段大小(MSS)**的限制\nChap 4 Network Layer: Data Plane   Let’s review some of the terminology used in this textbook. Recall that the name of a transport-layer packet is segmentand that the name of a link-layer packet is frame. What is the name of a network-layer packet? Recall that both routers and link-layer switches are called packet switches. What is the fundamental difference between a router and link-layer switch? 让我们回顾一下这本教科书中使用的一些术语。回想一下传输层包是段，链路层包的名称是帧。网络层包的名称是什么?回想一下，路由器和链路层交换机都被调用分组交换机。路由器和链路层交换机的基本区别是什么?  A network-layer packet is a datagram. A router forwards a packet based on the packet’s IP (layer 3) address. A link-layer switch forwards a packet based on the packet’s MAC (layer 2) address. 网络层数据包是数据报。路由器根据包的IP(第三层)地址转发包。链路层交换机根据数据包的MAC地址(第二层)转发数据包。\n We noted that network layer functionality can be broadly divided into data plane functionality and control plane functionality. What are the main functions of the data plane? Of the control plane? 我们注意到，网络层的功能可以大致分为数据平面功能和控制平面功能。数据平面的主要功能是什么?控制平面的?  The main function of the data plane is packet forwarding, which is to forward datagrams from their input links to their output links. For example, the data plane’s input ports perform physical layer function of terminating an incoming physical link at a router, perform link-layer function to interoperate with the link layer at the other side of the incoming link, and perform lookup function at the input ports. 数据平面的主要功能是包转发，即将数据报从输入链路转发到输出链路。例如，数据平面的输入端口执行物理层功能，即在路由器上终止传入的物理链路，执行链路层功能以与传入链路另一端的链路层互操作，并在输入端口执行查找功能。 The main function of the control plane is routing, which is to determine the paths a packet takes from its source to its destination. A control plane is responsible for executing routing protocols, responding to attached links that go up or down, communicating with remote controllers, and performing management functions. 控制平面的主要功能是路由，即确定数据包从源到目的地的路径。控制平面负责执行路由协议，响应上行或下行的附加链路，与远程控制器通信，执行管理功能。\n We made a distinction between the forwarding function and the routing function performed in the network layer. What are the key differences between routing and forwarding? 我们对网络层中执行的转发功能和路由功能进行了区分。路由和转发的主要区别是什么?  The key differences between routing and forwarding is that forwarding is a router’s local action of transferring packets from its input interfaces to its output interfaces, and forwarding takes place at very short timescales (typically a few nanoseconds), and thus is typically implemented in hardware. Routing refers to the network-wide process that determines the end-to-end paths that packets take from sources to destinations. Routing takes place on much longer timescales (typically seconds), and is often implemented in software. 路由和转发的关键区别在于，转发是路由器将数据包从输入接口传输到输出接口的本地动作，而转发发生在非常短的时间内(通常只有几纳秒)，因此通常是在硬件中实现的。路由是指确定信息包从源到目的地的端到端路径的网络范围的过程。路由发生在更长的时间尺度上(通常是秒)，并且通常是在软件中实现的。\n What is the role of the forwarding table within a router? 转发表在路由器中的作用是什么?  The role of the forwarding table within a router is to hold entries to determine the outgoing link interface to which an arriving packet will be forwarded via switching fabric. 转发表在路由器中的作用是保存表项，以确定到达的数据包将通过交换结构转发到哪个出接口。\n We said that a network layer’s service model “defines the characteristics of end-to-end transport of packets between sending and receiving hosts.” What is the service model of the Internet’s network layer? What guarantees are made by the Internet’s service model regarding the host-to-host delivery of datagrams? 我们说过，网络层的服务模型“定义了发送主机和接收主机之间的包的端到端传输的特征”。因特网的网络层的服务模型是什么?关于主机到主机的数据报传送，因特网的服务模型提供了什么保证?  The service model of the Internet’s network layer is best-effort service. With this service model, there is no guarantee that packets will be received in the order in which they were sent, no guarantee of their eventual delivery, no guarantee on the end-to-end delay, and no minimal bandwidth guarantee. 因特网网络层的服务模型是尽力而为服务。使用这种服务模型，不能保证数据包将按照它们发送的顺序接收，不能保证它们的最终交付，不能保证端到端延迟，也不能保证最小带宽。\n What does each input port of a high speed router store to facilitate fast for- warding decisions? 一个高速路由器的每个输入端口存储什么以方便快速的防止决定?   Suppose that an arriving packet matches two or more entries in a router’s forwarding table. With traditional destination-based forwarding, what rule does a router apply to determine which of these rules should be applied to determine the output port to which the arriving packet should be switched? 假设一个到达的数据包与路由器转发表中的两个或多个表项相匹配。对于传统的基于目的地的转发，路由器应该应用什么规则来确定应该应用这些规则中的哪一个来确定到达的数据包应该被交换到的输出端口?  A router uses longest prefix matching to determine which link interface a packet will be forwarded to if the packet’s destination address matches two or more entries in the forwarding table. That is, the packet will be forwarded to the link interface that has the longest prefix match with the packet’s destination. 如果报文的目的地址与转发表中的两个或两个以上的表项相匹配，路由器使用最长前缀匹配来确定报文将被转发到哪个链路接口。即报文将被转发到与报文目的地址前缀匹配最长的链路接口。\n Suppose Host A sends Host B a TCP segment encapsulated in an IP data- gram. When Host B receives the datagram, how does the network layer in Host B know it should pass the segment (that is, the payload of the datagram) to TCP rather than to UDP or to some other upper-layer protocol? 假设主机A向主机B发送一个封装在IP数据报中的TCP段。当主机B接收到数据报时，主机B中的网络层如何知道它应该将段(即数据报的有效负载)传递给TCP而不是UDP或其他一些上层协议?  The 8-bit protocol field in the IP datagram contains information about which transport layer protocol the destination host should pass the segment to. IP数据报中的8位协议字段包含关于目的地主机应该将段传递到哪个传输层协议的信息。\n What field in the IP header can be used to ensure that a packet is forwarded through no more than Nrouters? 在IP报头中有哪些字段可以用来保证一个报文转发不超过N路由器?  Time-to-live. 生存时间\n Recall that we saw the Internet checksum being used in both transport-layer segment (in UDP and TCP headers, Figures 3.7 and 3.29 respectively) and in network-layer datagrams (IP header, Figure 4.16). Now consider a transport layer segment encapsulated in an IP datagram. Are the checksums in the segment header and datagram header computed over any common bytes in the IP datagram? Explain your answer. 回想一下，我们在传输层段(分别在UDP和TCP报头中，图3.7和3.29)和网络层数据报(IP报头，图4.16)中都使用了Internet校验和。现在考虑一个封装在IP数据报中的传输层段。段报头和数据报报头中的校验和是否在IP数据报中的任何公共字节上计算?解释你的答案。  No. IP header checksum only computes the checksum of an IP packet’s IP header fields, which share no common bytes with the IP datagram’s transport-layer segment part. 不。IP报头校验和只计算IP包的IP报头字段的校验和，这些字段与IP数据报的传输层段部分不共享公共字节。\n When a large datagram is fragmented into multiple smaller datagrams, where are these smaller datagrams reassembled into a single larger datagram? 当一个大数据报被分割成多个较小的数据报时，这些较小的数据报在哪里重新组装成一个较大的数据报呢?  The reassembly of the fragments of an IP datagram is done in the datagram’s destination host. IP数据报的片段的重组是在数据报的目标主机中完成的。\n A router has eight interfaces. How many IP addresses will it have? 路由器有8个接口。它将有多少IP地址?   What is the 32-bit binary equivalent of the IP address 223.1.3.27 ? 与IP地址223.1.3.27对应的32位二进制文件是什么?  11011111 00000001 00000011 00011100.\n Suppose there are four routers between a source host and a destination host. Ignoring fragmentation, an IP datagram sent from the source host to the destination host will travel over how many interfaces? How many forward- ing tables will be indexed to move the datagram from the source to the destination? 假设在一个源主机和一个目标主机之间有四个路由器。如果忽略分片，从源主机发送到目标主机的IP数据报将经过多少个接口?将索引多少个转发表以将数据报从源移动到目的地?  8 interfaces; 3 forwarding tables.\n Suppose an application generates chunks of 40 bytes of data every 20 msec, and each chunk gets encapsulated in a TCP segment and then an IP datagram. What percentage of each datagram will be overhead, and what percentage will be application data? 假设一个应用程序每20 msec生成40字节的数据块，每个数据块封装在一个TCP段中，然后封装在一个IP数据报中。每个数据报的开销占多大百分比，应用程序数据占多大百分比?  50% overhead.\n What is a private network address? Should a datagram with a private network address ever be present in the larger public Internet? Explain. 什么是私网地址?具有专用网络地址的数据报是否应该出现在更大的公共互联网中?解释一下。  A private network address of a device in a network refers to a network address that is only meaningful to those devices within that network. A datagram with a private network address should never be present in the larger public Internet, because the private network address is potentially used by many network devices within their own private networks. 网络中设备的专用网络地址指的是仅对该网络中的设备有意义的网络地址。具有专用网络地址的数据报永远不应该出现在更大的公共Internet中，因为专用网络地址可能被它们自己的专用网络中的许多网络设备使用。\n Chap 5 Network Layer: Control Plane   True or false: When an OSPF route sends its link state information, it is sent only to those nodes directly attached neighbors. Explain. OSPF路由发送链路状态信息时，只发送给与它直接相连的邻居。解释一下。  OSPF（ Open Shortest Path First ） False With OSPF, a router broadcasts its link-state information to all other routers in the autonomous system to which it belongs, not just to its neighboring routers. This is because with OSPF, each router needs to construct a complete topological map of the entire AS and then locally runs Dijkstra’s shortest-path algorithm to determine its least- cost paths to all other nodes in the same AS. OSPF要广播链路信息，每台路由器都需要构造一个完整的整个自治系统的拓扑图。\n True or false: When a BGP router receives an advertised path from its neighbor, it must add its own identity to the received path and then send that new path on to all of its neighbors. Explain. 当BGP路由器接收到邻居发布的路径时，它必须在接收到的路径上添加自己的身份，然后将新的路径发送给所有邻居。解释一下。  BGP （ Border Gateway Protocol ）边界网关协议 False. A BGP router can choose not to add its own identity to the received path and then send that new path on to all of its neighbors, as BGP is a policy-based routing protocol. This can happen in the following scenario. The destination of the received path is some other AS, instead of the BGP router’s AS, and the BGP router does not want to work as a transit router. BGP可以选择不添加信息（当不希望作为中转路由器工作时）\n What is meant by a control plane that is based on per-router control? In such cases, when we say the network control and data planes are implemented “monolithically,” what do we mean? 基于每个路由器控制的控制平面是什么意思?在这种情况下，当我们说网络控制和数据平面是“单一的”实现时，我们的意思是什么?  Per-router control means that a routing algorithm runs in each and every router; both forwarding and routing function are constrained within each router. Each router has a routing component that communicates with the routing components in other routers to compute the values for its forwarding table. In such cases, we say that the network control and data planes are implemented monolithically because each router works as an independent entity that implements its own control and data planes. 每个路由器控制意味着路由算法在每个路由器上运行;在每个路由器中，转发和路由功能都受到限制。每个路由器都有一个路由组件，该组件与其他路由器中的路由组件通信，以计算其转发表的值。在这种情况下，我们说网络控制和数据平面是单个实现的，因为每个路由器都作为一个独立的实体来实现自己的控制和数据平面。\n What is meant by a control plane that is based on logically centralized control? In such cases, are the data plane and the control plane implemented within the same device or in separate devices? Explain. 基于逻辑集中控制的控制平面是什么意思?在这种情况下，数据平面和控制平面是在同一个设备中实现还是在单独的设备中实现?解释一下。  Logically centralized control means that a logically central routing controller computes and distributes the forwarding tables to be used by each and every router, and each router does not compute its forwarding table, unlike the per-router control. In the case of logically centralized control, the data plane and control plane are implemented in separate devices; the control plane is implemented in a central server or multiple servers, and the data plane is implemented in each router. 逻辑集中控制是指一个逻辑上集中的路由控制器计算并分配每个路由器使用的转发表，而每个路由器不计算它的转发表，这与per-router控制不同。在逻辑集中控制的情况下，数据面和控制面分别在不同的设备上实现;控制平面在一台或多台服务器中实现，数据平面在每台路由器中实现。\n Chap 6 The Link Layer and LANs   What is framing in link layer? 链接层中的框架是什么?   If all the links in the Internet were to provide reliable delivery service, would the TCP reliable delivery service be redundant? Why or why not? 如果Internet上的所有链路都提供可靠的交付服务，TCP的可靠交付服务会是冗余的吗?为什么或为什么不?  Although each link guarantees that an IP datagram sent over the link will be received at the other end of the link without errors, it is not guaranteed that IP datagrams will arrive at the ultimate destination in the proper order. With IP, datagrams in the same TCP connection can take different routes in the network, and therefore arrive out of order. TCP is still needed to provide the receiving end of the application the byte stream in the correct order. Also, IP can lose packets due to routing loops or equipment failures. 尽管每个链路都保证了在链路上发送的IP数据报将在链路的另一端没有错误地接收到，但它不能保证IP数据报将以正确的顺序到达最终目的地。使用IP，同一TCP连接中的数据报在网络中可以通过不同的路由到达，因此到达的顺序是不一致的。TCP仍然需要以正确的顺序向应用程序的接收端提供字节流。此外，由于路由环路或设备故障，IP可能会丢失数据包。\n Name three error-detection strategies employed by link layer. 链路层使用的三种错误检测策略。   Suppose two nodes start to transmit at the same time a packet of length Lover a broadcast channel of rate R. Denote the propagation delay between the two nodes as dprop. Will there be a collision if dprop 6 L/R? Why or why not? 假设两个节点在速率为r的广播信道上同时开始传输长度为L的数据包，表示两个节点之间的传播延迟为dprop。如果dprop\u0026lt;L/R会有碰撞吗?为什么或为什么不?  There will be a collision in the sense that while a node is transmitting it will start to receive a packet from the other node. 当一个节点在传输时，它将开始从另一个节点接收数据包，这样就会产生冲突。\n How big is the MAC address space? The IPv4 address space? The IPv6 address space? MAC地址空间有多大?IPv4地址空间?IPv6地址空间?  2^48 MAC addresses; 2^32 IPv4 addresses; 2^128 IPv6 addresses.\n Suppose nodes A, B, and C each attach to the same broadcast LAN (through their adapters). If A sends thousands of IP datagrams to B with each encapsulating frame addressed to the MAC address of B, will C’s adapter process these frames? If so, will C’s adapter pass the IP datagrams in these frames to the network layer C? How would your answers change if A sends frames with the MAC broadcast address? 假设节点A、B和C都连接到同一个广播局域网(通过它们的适配器)。如果A发送数千个IP数据报给B，每个封装帧都被编址到B的MAC地址，C的适配器会处理这些帧吗?如果是，C的适配器将这些帧中的IP数据报传递到网络层C吗?如果A用MAC广播地址发送帧，你的答案会如何变化?  C’s adapter will process the frames, but the adapter will not pass the datagrams up the protocol stack. If the LAN broadcast address is used, then C’s adapter will both process the frames and pass the datagrams up the protocol stack. C的适配器将处理帧，但适配器不会将数据报向上传递到协议栈。如果使用了局域网广播地址，那么C的适配器将处理帧并将数据报向上传递到协议栈。\n Why is an ARP query sent within a broadcast frame? Why is an ARP response sent within a frame with a specific destination MAC address? 为什么ARP查询在广播帧内发送?为什么ARP响应在特定目的MAC地址的帧内发送?  An ARP query is sent in a broadcast frame because the querying host does not which adapter address corresponds to the IP address in question. For the response, the sending node knows the adapter address to which the response should be sent, so there is no need to send a broadcast frame (which would have to be processed by all the other nodes on the LAN). ARP查询是在广播帧中发送的，因为查询主机不知道哪个适配器地址对应的IP地址。对于响应，发送节点知道响应应该发送到的适配器地址，因此不需要发送广播帧(该帧必须由LAN上的所有其他节点处理)。\n For the network in Figure6.19, the router has two ARP modules, each with its own ARP table. Is it possible that the same MAC address appears in both tables? 对于图6.19中的网络，路由器有两个ARP模块，每个模块都有自己的ARP表。是否可能在两个表中出现相同的MAC地址?  No it is not possible. Each LAN has its own distinct set of adapters attached to it, with each adapter having a unique LAN address. 不，这不可能。每个局域网都有自己独特的适配器集，每个适配器都有一个独特的局域网地址。\n What is a hub used for?   Consider Figure 6.15. How many subnetworks are there, in the addressing sense of Section 4.3? 考虑图6.15。在第4.3节的寻址意义上，有多少个子网?  2 (the internal subnet and the external internet) 2(内部子网和外部互联网)\n Each host and router has an ARP table in its memory. What are the contents of this table?   Calculation and Analysis  假设用户共享一条3mbps的链路。再假设每个用户在传输时需要150 kbps，但是每个用户只传输10%的时间。(参见第1.3节中分组交换与电路交换的讨论。) a.使用电路切换时，支持多少用户? b.对于这个问题的其余部分，假设使用了分组交换。找出给定用户进行传输的概率。 c.假设有120个用户。求任意给定时刻，恰好有n个用户同时进行传输的概率。(提示:使用二项分布。) d.求同时有21个以上用户在传输的概率。\n在包括因特网在内的现代分组交换网络中，源主机将长应用层消息(例如，一个图像或一个音乐文件)分段成更小的分组，并将这些分组发送到网络中。然后，接收方将数据包重新组装成原始消息。我们将此过程为消息分段。 图1.27演示了带有和不带有消息分段的消息的端到端传输。考虑图1.27中从源发送到目的地的长度为8 # 106位的消息。假设图中每条链路为2mbps。忽略传播、队列和处理延迟。 a.考虑在不分段的情况下将消息从源发送到目的地。将消息从源主机移动到第一个包交换机需要多长时间?请记住，每个交换机使用存储和转发分组交换，将消息从源主机移动到目标主机的总时间是多少? b.现在假设消息被分成800个数据包，每个数据包有10000位长。将第一个包从源主机移动到第一个交换机需要多长时间?当第一个数据包从第一个交换机发送到第二个交换机时，第二个数据包从源主机发送到第一个交换机。在第一个交换机上什么时候会完全接收到第二个数据包? c.使用消息分段时，将文件从源主机移动到目标主机需要多长时间?将这一结果与你(a)部分的答案进行比较并评论。 d.除了减少延迟之外，使用消息分段的原因是什么? e.讨论消息分段的缺点。\n考虑以下ASCII字符串，当浏览器发送一个HTTP GET消息时，Wireshark捕获了这些字符(即，这是一个HTTP GET消息的实际内容)。字符是回车和换行字符(也就是说，下面文本中的斜体字字符串表示HTTP报头中此时包含的单个回车字符)。回答以下问题，指示您在下面的HTTP GET消息中找到答案的位置。\n考虑发送方窗口大小为4、序列号范围为1024的GBN协议。假设在时间t时，接收方期望的下一个有序包的序列号为k。假设媒体不重新对消息进行排序。请回答以下问题: a.在时间t时，发送方窗口内可能存在的序列号集合是什么?证明你的答案。 b.在时间t时，在所有可能的消息中，ACK字段的所有可能值是什么?证明你的答案。\n这里我们有一个窗口大小N=3。假设接收方收到了数据包k-1，并对该数据包和之前所有其他数据包进行了ack。如果所有这些ACK都已被发送方接收，那么发送方的窗口是[k, k+N-1]。接下来，假设发送方没有收到任何ack。在第二种情况下，发送方的窗口包含k-1和k-1以内(包括k-1)的N个包。因此发送方的窗口是[k-N,k-1]。通过这些参数，发送者窗口的大小为3，开始于[k- n,k]范围内的某个地方。 b)如果接收方在等待报文k，则接收到(并进行了ack)的报文k-1和之前的报文N-1。如果发送方尚未接收到这些N个ACK，则值为[k-N,k-1]的ACK消息可能仍在往回传播。因为发送方已经发送了数据包[k-N, k-1]，所以必须是发送方已经收到了k-N-1的ACK。一旦接收端发送了一个k-N-1的ACK，它将永远不会发送小于k-N-1的ACK。因此，飞行中ACK值的范围可以从k-N-1到k-1。\n考虑将一个L字节的大文件从主机A传输到主机b，假设MSS为536字节。 a.不耗尽TCP序列号的最大L值是多少?回想一下TCP序列号字段有4个字节。 b.对于在(a)中获得的L，找出传输文件需要的时间。假设总共有66字节的传输、网络和数据链路头被添加到每个段，然后产生的包通过155 Mbps的链路发送出去。忽略流量控制和拥塞控制，使A可以连续地泵出段。\n有232 = 4,294,967,296可能的序列号。 a)序号不会随着每段递增1。相反,它 按发送数据的字节数递增。因此MSS的大小无关紧要——从A发送到B的最大文件大小仅仅是字节数 可表示为232»4.19 gb。 b)段数isê536ú。66个字节的头被添加到每个 段给出了总计528,857,934字节的头。传输的总字节数为232 + 528,857,934 = 4.824́109字节。 因此，在155~Mbps的链路上传输文件需要249秒。\n主机A和B通过TCP连接进行通信，主机B已经从A接收到126字节以上的所有字节。假设主机A向主机B背靠背发送两个网段。第一个和第二个段分别包含80和40字节的数据。其中第一个报文段序号为127，源端口号为302，目的端口号为80。每当主机B从主机a接收到一个段时，它都会发送一个确认。 a.主机a发送给B的第二段，序列号- ber、源端口号、目的端口号分别是什么? b.如果第一个报文段在第二个报文段之前到达，在第一个报文段的确认中，确认号、源端口号和目的端口号分别是什么? c.如果第二段在第一段之前到达，在第一段到达的确认中，确认号是多少? d.假设A发送的两个片段顺序到达b。第一个确认丢失，第二个确认在第一个超时间隔之后到达。画一个时间表，显示这些段和所有其他段和确认发送。(假设没有额外的丢包。)对于图中的每个段，提供序列号和数据的字节数;对于您添加的每一个确认，请提供确认号码。\na)主机a到主机B的第二段，序号为207，源端口号为302，目的端口号为80。 b)如果第一个报文段在第二个报文段之前到达，则第一个报文段的确认号为207，源端口号为80，目的端口号为302。 c)如果第二个段在第一个段之前到达，在第一个到达的段的确认中，确认号是127，表示它仍然在等待127字节及以后的字节。\n第29页。第3.5.6节讨论了SYN cookie a.为什么服务器需要在SYNACK中使用特殊的初始序列号? b.假设攻击者知道目标主机使用SYN cookie。攻击者能否通过简单地向目标发送一个ACK包来创建半开或完全打开的连接?为什么或为什么不? 假设攻击者收集了大量服务器发送的初始序列号。攻击者是否可以通过发送带有这些初始序列号的ack来导致服务器创建许多完全打开的连接?为什么?\na)服务器使用特殊的初始序列号(从源ip、目的ip和端口的哈希值中获取)来防御SYN FLOOD攻击。 b)不能，攻击者不能通过简单的发送和ACK报文来创建半开或完全开的连接。半开放的连接是不可能的，因为在建立完整连接之前，使用SYN cookie的服务器不会为任何连接维护连接变量和缓冲区。为了建立完全开放的连接，攻击者应该知道与攻击者(欺骗的)源IP地址对应的特殊初始序列号。这个序列号需要每个服务器使用的“秘密”编号。由于攻击者不知道这个秘密数字，她无法猜测初始序列号。 c)不，服务器可以简单地在计算这些初始序列号时添加一个时间戳，并为这些序列号选择一个存活时间，并丢弃过期的初始序列号，即使攻击者重放它们。\n在3.5.4节中，我们看到TCP在执行快速重传之前一直等待，直到它收到三个重复的ack。为什么你认为TCP设计者选择不执行一个段的第一个重复ACK后的快速重传?\n假设发送了数据包n、n+1和n+2，并接收了数据包n并进行了ack。如果数据包n + 1, n + 2沿着end-to-end-path会重新排序(例如,收到的顺序n + 2, n + 1)的收据包n + 2将生成一个重复的ack n和将引发重传下的政策只有等待第二个重复ack重传。通过等待三重重复的ACK，它必须是两个第n包后的报文正确收到，而第n+1包未收到。三重重复ACK方案的设计者可能认为等待两个包(而不是1个)是在需要时触发快速重传之间的正确权衡，而不是在面对包重新排序时过早重传。\n在这个问题中，我们研究UDP或TCP是否提供了某种程度的端点身份验证。 a.考虑一个服务器接收一个UDP报文中的请求，并响应该请求的UDP报文(例如，由DNS服务器所做)。如果一个IP地址为X的客户机用地址Y来欺骗它的地址，那么服务器将在哪里发送它的响应? b.假设服务器收到源地址为Y的SYN报文，通过SYNACK响应后，收到确认号正确的源地址为Y的ACK报文。假设服务器选择一个随机的初始序列号，并且没有“中间人”，服务器能确定客户端确实在Y(而不是欺骗Y的其他地址X)吗?\na)服务器将响应发送给Y。 b)服务器可以确定客户端确实在Y。如果它在其他地址欺骗Y，则SYNACK将被发送到地址Y，并且该主机中的TCP不会发送回TCP ACK段。即使攻击者发送一个适当时间的TCP ACK段，它也不知道正确的服务器序列号(因为服务器使用随机的初始序列号)。\n考虑一个使用32位主机地址的数据报网络。假设一台路由器有4条链路，编号从0到3，报文按如下方式发送到链路接口:\na.提供5个表项的转发表，使用最长前缀匹配，将报文转发到正确的链路接口。 b.描述转发表如何为带有目的地址的数据报确定适当的链路接口: 第一个地址的前缀匹配为第5个表项:link接口3第二个地址的前缀匹配为第3个表项:link接口2 第三个地址的前缀匹配是第4 Entry: link interface 3\n考虑一个使用8位主机地址的数据报网络。假设一台路由器使用最长前缀匹配，并且有如下转发表: 对于这四个接口中的每个接口，给出与之关联的目的主机地址范围和范围内的地址数量。\n","permalink":"https://github.com/FreanJa/freanja.github.io/post/2021-07-02/","summary":"Chap 1 Introduction   What is the difference between a host and an end system? List several different types of end systems. Is a Web server an end system?  ANS There is no difference. Throughout this text, the words “host” and “end system” are used interchangeably. End systems include PCs, workstations, Web servers, mail servers, PDAs, Internet-connected game consoles, etc.\n 没有区别。在本文中，“主机”和“终端系统”这两个词是互换使用的。 终端系统包括pc机、工作站、Web服务器、邮件服务器、pda、联网游戏机等。 Web服务器也是终端系统   Describe the protocol that might be used by two people having a telephonic conversation to initiate and end the conversation.","title":"CN knowledge combing"}]